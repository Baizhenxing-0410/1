# 第七章：MySQL数据库

#### 本章具体小节如下：   

1. **第一节:MySQL介绍和安装**
2. **第二节:MySQL库表详细操作**
3. **第三节:MySQL行(记录)的详细操作**
4. **第四节:Navicat工具的安装和使用**
5. **第五节:pymysql模块**
6. **第六节:索引**
7. **第七节:创建用户和授权**
8. **MySQL数据备份与还原**



#### 1.什么是数据库

​	百度说法：

```
    数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。
    所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。
```

​	为了方便的管理这些数据，又能提高对数据的管理效率，各个公司就开始想办法了，喊出了口号：我们要写一套软件，专门管理数据！！让应用程序或者说项目程序不直接和硬盘打交道了，让我们自己写的管理数据的软件来操作数据，并且我们写的软件要解决下面几个问题：1.直接操作硬盘上的文件效率低 。 2. 通过操作文件来读写数据很麻烦。 3. 我们自己的电脑上写的程序和我们自己电脑上存储的数据都在这一台电脑上了，想和别人共享一个数据或者一个文档也是比较麻烦的，并且如果和别人共享，那么可能造成自己电脑的安全性变低了，但是公司内部的项目可能就会使用一些共同的数据啊，这样共享起来就很麻烦。 4. 项目和数据如果都在一个电脑上，例如京东，如果有一天，京东的项目出问题了，或者部署这个项目的电脑（服务器）崩了，你的数据是不是就麻烦了，嗯，稳定性和安全性都不够，我们要把数据和项目分开管理，一般公司都会这么做，看下图：

​	![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106102600773-1880943180.png)

​	通过上面这个图里面的思想，貌似解决了共享数据和数据稳定性的问题，但是专门管理数据的机器里面还是将数据存到硬盘上啊，如果项目直接和硬盘打交道，效率还是差啊，并且虽然数据共享起来了，我们通过前面的学习知道，数据共享起来就会出现数据不安全的问题和数据混乱的问题啊，怎么办，加锁！而且很多项目或者人都可能过来连接中间这个存放数据的机器啊，我们不能让所有人都能连接这个机器啊，怎么办，加连接验证！并且要做好备份，因为现在数据多重要啊，所以还要支持做数据备份的工作！多个人连接使用这个机器中的数据的时候，还要支持并发啊，每个人的感觉都是自己单独的在操作这个机器啊，怎么办，支持并发！

　　哎，想要好好的玩数据，还真是tm的麻烦，不过各个公司都不怕艰难，都在努力的搞事情，搞一套可以高效管理数据的工具，称之为数据库管理软件/系统（应用软件）

　　又出来一个新词啊，数据库管理系统，来，先看看百度怎么解释的

```
数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的计算机类型来作分类，例如服务器群集、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高运行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言。
```

​	貌似又是不好理解，来吧，通俗解释--> 这个工具负责来和硬盘打交道(当然中间还隔着操作系统)，高效的管理数据，并且还支持对外通信，网络通信都是基于socket，也就是说它还相当于一个socket服务端，那么想来到这个存数据的机器上来操作数据的人或者项目都可以连接到这个工具，并通过这个工具来管理数据，那么我们就可以通过下面这个图来看看这工具的工作方式：

​          ![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106114045587-1458879858.png)

​	上面这个图是不是就一目了然了，这个数据管理系统我们称之为DBMS，DB（database）就是数据库的意义，M（manage）就是管理的意思，S（system）就是系统的意思，其实就是英文名的首字符缩写。市场上冒出了很多优秀的数据库管理系统，例如：mysql、oracle、db2等等，人家开发好了，你使用就行了，既然是使用别人写好的数据库管理系统，那么我们在操作的时候，就要按照人家的规范来操作，这个规范叫做sql，我们通过这个系统来操作数据的语句叫做sql语句。那么过程就是这个样子的：首先下载安装人家的数据管理系统，然后启动系统，我们的项目如果想通过这个系统来操作数据，那么就需要你的项目中写一个socket客户端，要满足人家这个系统的服务端的消息格式要求，然后就按照人家规定好的sql语句写好操作数据的命令，使用你的写好的客户端通过网络发送给这个存放数据的机器上的数据管理系统的服务端，服务端接到这个命令之后，解析，然后产生对应的数据操作，你要是查询数据，就将查询数来的数据原路返回给你，如果你要是修改数据，那么我服务端就在系统上修改对应的数据。这就是整个操作流程了，其实这个系统就是一个基于socket编写的C/S架构的软件。

　　有人称这个数据管理系统为数据库，有人称这个存放数据的机器叫做数据库，有人称里面的一个存放数据的库叫做数据库，（存放数据的库，其实就是将数据分开管理，例如：你有两个项目来使用这个数据管理系统，那么我们两个项目的数据肯定是不能掺和在一块的对不对，那么就需要分开管理，分开管理的是可以给每个项目单独创建一个库，每个库存放自己项目对应的数据，有人称这个库为数据库），但是不管怎么称呼，你结合他当时说话的场景，就能够理解他指的是什么了，反正大意也都差不多，这个知道就好了。那么我们来看看有哪些NB的数据库管理系统啊，看下节的分类（还是先安装一下mysql搞一下看看再看分类吧！直接看第三大节）。

#### 2.数据库分类

​	目前的数据库可以分为两个大类：关系型数据库和非关系型数据库

1. 关系型数据库

**解释：**关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式，不是excel，但是和excel的形式很像），结合下图来看一下，

![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106153308881-478398058.png)

​	这个表看着好乱啊，但是你细看一下，这几个表之间建立了某种关系，共享着双方的数据。这就是关系。关系型数据库里面存数据的时候就类似这个样子的。有个大概了解了吗~~~

​	操作关系型数据库的命令，我们称之为SQL，看解释

```
结构化查询语言(Structured[ˈstrʌktʃərd] Query Language)简称SQL(发音：/ˈes kjuː ˈel/ "S-Q-L")，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。
结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。
1986年10月，美国国家标准协会对SQL进行规范后，以此作为关系式数据库管理系统的标准语言（ANSI X3. 135-1986），1987年得到国际标准组织的支持下成为国际标准。不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用
```

​	其中最后一句挺重要的：**不同数据库系统之间的SQL不能完全相互通用**

 2. 常见的关系型数据库

    （1）oracle数据库

    ​	Oracle前身叫SDL、由Larry Ellison（拉里·埃里森）和同事Robert Miner（罗伯特·米纳）在1977创办，Oracle公司是最早开发关系型数据库的厂商之一，其产品支持最广泛的操作系统平台。目前Oracle关系数据库产品的市场占有率数一数二 。
    ​	Oracle公司是目前全球最大的数据库软件公司，也是近年业务增长极为迅速的软件提供与服务商 
    ​	主要应用范围：传统大企业、大公司、政府、金融、证券等。 
    ​	版本升级：oracle8i，oracle9i，oracle10g，oracle11g，oracle12c

     （2） MySQL

    ​	MySQL被广泛的应用在Internet上的大中小型网站中。由于体积小、速度快、总体拥有成本低，开放源代码

     （3）  MariaDB数据库

    ​	MAriaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。开发这个MariaDB的原因之一是：甲骨文公司收购了MySQL后，有MySQL闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。 

    ​	MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM的存储引擎，它使用了Percona的XtraDB（InnoDB的变体）这个版本还包括了PrimeBase XT （PBXT）和Federated X存储引擎。

     （4） SQL Server数据库

    ​	Microsoft SQL Server是微软公司开发的大型关系数据库系统。SQL Server的功能比较全面，效率高，可以作为中型企业或单位的数据库平台。SQL Server可以与Winodws操作系统紧密集成，不论是应用程序开发速度还是系统事务处理运行速度，都得到较大的提升，对于在Windows平台上开发的各种企业级信息管理系统来说，不论是C/S（客户机/服务器）架构还是B/S（浏览器/服务器）架构。SQL Server都是一个很好的选择。SQL Server的缺点是只能在Windows系统下运行。

     （5）  Access数据库

    ​	Access是入门级小型桌面数据库，性能安全性都很一般，可供个人管理或小型企业只用 
    ​	Access不是数据库语言，只是一个数据库程序，目前最新版本为Office 2007，其特点主要如下： 
    ​	（1）完善地管理各种数据库对象，具有强大的数据组织，用户管理、安全检查等功能 
    ​	（2）强大的数据处理功能，在一个工作组级别的网络环境中，使用Access开发的多用户管理系统具有传统的XSASE(DBASE、FoxBASE的统称)数据库系统所无法实现的客户服务器（Ckient/Server）结构和响应的数据库安全机制，Access具备了许多先进的大型数据管理管理系统所具备的特征。 
    ​		3）可以方便地生成各种数据对象，利用存储的数据建立窗体和报表 
    ​		4）作为Office套件的一部分，可以与Office集成，实现无缝连接 
    ​		5）能够利用Web检索和发布数据，实现与Internet的连接，Access主要适用于中小企业应用系统，或作为客户机/服务器系统中的客户端数据库。

    ​		6）  其他不常用关系型数据库

    ​	DB2，PostgreSQL，Informix，Sybase等。这些关系型数据库逐步的淡出了普通运维的视线，特别是互联网公司几乎见不到

3. 非关系型数据库

​	**非关系型数据库也被成为NoSQL数据库，NOSQL的本意是“Not Only SQL”** 

​	指的是非关系型数据库，而不是“No SQL”的意思，因此，NoSQL的产生并不是要彻底地否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。 

​	随着互联网Web2.0网站的兴起，传统的关系型数据库在应付web2,0网站，特别是对于规模日益扩大的海量数据，超大规模和高并发的微博、微信、SNS（ 社交网络服务 ）类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。 

​	例如：传统的关系型数据库IO瓶颈、性能瓶颈都难以有效突破，于是出现了大批针对特定场景，以高性能和使用便利为目的功能特异化的数据库产品。NOSQL（非关系型）类的数据库就是在这样的情景下诞生并得到了非常迅速的发展。其特性有：高性能、高并发、对数据一致性要求不高 。
​	开源的NoSQL体系，如Facebook的Cassandra（ [kəˈsændrə] (尤指无人相信的)凶事预言者），Apache的HBase，也得到了广泛认同，Redis，mongDB也逐渐越来越受到各类大中小型公司的欢迎和追捧 

​	NOSQL非关系型数据库小结： 
​	1、NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充 
​	2、NOSQL为了高性能、高并发而生，忽略影响高性能，高并发的功能 
​	3、NOSQL典型产品memcached // [,mem'kæʃt] //（纯内存），redis（持久化缓存），mongodb（文档的数据库） 

​	**非关系型数据库又分为以下4种：**

（1）键值（Key-Value）存储数据库
        键值数据库就类似传统语言中使用哈希表，可以通过key来添加、查询或删除数据，因为使用key主键访问，所以会获得很高的性能及扩展性 
    键值（Key-Value）数据库主要是使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发 
    k1—>数据 
    k2—>数据 
    典型产品：Memcached、Redis、MemcacheDB、BerkeleyDB ([ˈbɜrkli] 伯克利)

（2）列存储（Column（[ˈkɑːləm]）-oriented（[ˈɔːrientɪd]面向的））数据库 ======>了解即可，一般公司用不到。
         这部分数据库通常用来分布式存储的海量数据，键仍然存在，但是他们的特点是指向了多个列。 
        典型产品：Cassandra [kəˈsændrə] ,HBase 

（3）面向文档（Document-Oriented）数据库
        面向文档数据库会将以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关系对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。
        典型产品：MorgoDB、CouchDB  （couch [kaʊtʃ] 沙发）

（4）图形（Graph [ɡræf]）数据库

​	图由两个元素组成：`节点`和`关系`。
​	每个节点代表一个实体（人，地，事物，类别或其他数据），每个关系代表两个节点的关联方式。这种通用结构可以对各种场景进行建模 - 从道路系统到设备网络，到人口的病史或由关系定义的任何其他事物。
​	`图形数据库(Graph database)`并非指存储图片的数据库，而是以`图`这种数据结构存储和查询数据。
​	`图形数据库`是一种在线数据库管理系统，具有处理图形数据模型的创建，读取，更新和删除（CRUD）操作。
​	与其他数据库不同，`关系`在图数据库中占首要地位。这意味着应用程序不必使用外键或带外处理（如MapReduce）来推断数据连接。
​	与关系数据库或其他NoSQL数据库相比，图数据库的数据模型也更加简单，更具表现力。
​	图形数据库是为与事务（OLTP）系统一起使用而构建的，并且在设计时考虑了事务完整性和操作可用性。
​	典型产品： Neo4J（Neo [niːoʊ] 【计】最新式）、 JanusGraph （Janus [ˈdʒeɪnəs] （罗神）杰纳斯（守护门户的两面神）;双向天线）



4. 常见的非关系型数据库

   （1）  memcached（key-value）

   　　Memcaced是一个开源的、高性能的、具有分布式内存对象的缓存系统。通过它可以减轻数据库负载，加速动态的web应用，最初版本由LiveJoumal（ 一个综合型SNS交友网站 ）的Brad Fitzpatrick（布拉德·菲茨帕特里克）在2003年开发完成。目前全球有非常多的用户都在使用它来架构主机的大负载网站或提升主机的高访问网站的响应速度。注意：Memcache 是这个项目的名称，而Memcached是服务端的主程序文件名。 
   		缓存一般用来保存一些进程被存取的对象或数据，通过缓存来存取对象或数据要比在磁盘上存取块很多，前者是内存，后者是磁盘、Memcached是一种纯内存缓存系统，把经常存取的对象或数据缓存在memcached的内存中，这些被缓存的数据被程序通过API的方式被读取，memcached里面的数据就像一张巨大的hash表，数据以key-value对的方式存在。Memcached通过缓存经常被存取的对象或数据，从而减轻频繁读取数据库的压力，提高网站的响应速度，构建出快速更快的可扩展的Web应用。 
   　　官网：http://memcached.org/ 
   　　由于memcached为纯内存缓存软件，一旦重启所有数据都会丢失，因此，新浪网基于Memcached开发了一个开源项目Memcachedb。通过为Memcached增加Berkeley DB的特久化存储机制和异步主复制机制，使Memcached具备了事务恢复能力、持久化数据能力和分布式复制能力，memcached非常适合需要超高性能读写速度、持久化保存的应用场景，但是最近几年逐渐被其他的持久化产品替代如Redis

   　　Memcached小结： 
   　　1、key-value行数据库 
   　　2、纯内存数据库 
   　　3、持久化memcachedb（sina）

   （2）  Redis（key-value）

   ​		和Memcached类似，redis也是一个key-value型存储系统。但redis支持的存储value类型相对更多，包括string（字符串）、list（链表）、set（集合）和zset（有序集合）等。这些数据类型都支持push/pop、add/remove及取交集、并集和差集及更丰富的操作，而且这些操作都是原子性的。为了保证效率，redis的数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在基础上实现了master-slave（主从）同步。 

   　　redis是一个高性能的key-value数据库。redis的出现、很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python、Ruby、Erlang、PHP客户端，使用方便。 
   　　官方：http://www.redis.io/documentation 
   　　redis特点： 
   　　1）支持内存缓存，这个功能相当于memcached 
   　　2）支持持久化存储，这个功能相当于memcachedb，ttserver 
   　　3）数据库类型更丰富。比其他key-value库功能更强 
   　　4）支持主从集群、分布式 
   　　5）支持队列等特殊功能 
   　　应用：缓存从存取memcached更改存取redis

   （3）  MongoDB（Document-oriented）

   　　MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据库结构非常松散，类似json的bjson格式，因此可以存储比较复杂的数据类型。Mongodb最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 

   　　特点： 
   　　　　高性能、易部署、易使用、存储数据非常方便 
   　　主要功能特性： 

   　　　　1.面向集合存储，易存储对象类型的数据 
   　　　　2.“面向集合”（Collection [kəˈlekʃn]-Orented）意思是数据库被分组存储在数据集中，被称为一个集合（Collection）。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档，集合的概念类似关系型数据库（RDBMS）里的表（table）不同的是它不需要定义任何模式（schema [ˈskiːmə]架构） 
   　　　　3.模式自由 
   　　　　　　模式自由（schema-free）意味着存储在mongodb数据库中的文件，我们不需要知道它的任何结构定义。 
   　　　　4.支持动态查询 
   　　　　5.支持完全索引，包含内部对象 
   　　　　6.支持查询 
   　　　　7.支持复制和故障恢复 
   　　　　8.使用高效的二进制数据存储，包括大型对象 
   　　　　9.自动处理碎片以支持云计算层次的扩展性
   （4）  Cassandra [kəˈsændrə]（Column[ˈkɑːləm] -oriented）

   　　Apache Cassndra是一套开源分布式Key-Value存储系统。它最初由Facebook开发，用于存储特别大的数据。Facebook目前在使用此系统。 
   主要特点： 

   　　1.分布式 
   　　2.基于column的结构化 
   　　3.高伸展性 
   　　4.Cassandra的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成一个分布式网络服务，对Cassandra的一个写操作，会被复制到其他节点上去，对Cassandra的读操作。也会被路由到某个节点上面去读取。 
   　　Cassandir是一个混合型的非关系的数据库，类似于Google的BigTable。其主要功能比Dynomie// dai'noʊmi //（分布式的key-value存储系统）更丰富，Cassandra最初由Facebook开发，后转变成了开源项目。

   （5）  其他不常用非关系型数据库

   　　HBase、MemcacheDB、BerkeleyDB、Tokyo Cabinet（[ˈkæbɪnət]内阁）\Tokyo Tyrant（[ˈtaɪrənt] 暴君）（ttserver） 
   　　ttserver 持久化输出，缺点：存储2千万条 性能下降（由日本人发明）

看了这么多的数据库，我们主要讲的是**MySQL**，这个公司里面非常常用的又非常nb的关系型数据库，后面还会讲一些非关系型数据库的使用，来吧，我们好好认识一下MySQL，看下一节介绍！

## 第一节 MySQL介绍和安装

#### 本节具体内容如下：        

1. **MySQL介绍**

2. **MySQL的下载安装、简单应用及目录介绍**      

   - MySQL下载安装
   - MySQL安装目录介绍
   - root用户密码设置及忘记密码的解决方法
   - 修改字符集编码	

   ​                          

#### 1.MySQL介绍

​	**MySQL版本**
　　　　双授权版本：社区版（完全免费，功能也够nb了）和商业版（更好，功能更多更强大一些，但是收费，VIP，有售后服务，也会参考和吸收社区版的一些nb的功能，安全性和稳定性都是最好的，大几十万），一般NB的开源软件都是双授权的
　　　　每个版本又分四个版本依次进行发布：
　　　　　　Alpha版：一般只在开发公司内部使用，不对外公开，测试、自我检查的版本
　　　　　　Beta版：一般是开发完也测试完的版本，一般不会出现比较大的性能bug（一般我们不用，阿里、去哪儿会使用这个版本，有些新功能，内部有高手能调，也能评估新功能的性能）
　　　　　　RC版：根据Beta版测试之后收集到一些bug等在进行完善的一个版本
　　　　　　GA版：软件正式发布的版本，没有特别的需求一定要使用GA版，有些公司追求新功能会使用Beta版，这是个例。

　　**MySQL的产品线：**（mysql是C++写的，oracle 9i版本之前是C语言写的，之后主要是java）
　　　　最早期，mysql是按照3.x--4.x--5.x等来开发的，但是为了提高MySQL的竞争优势，以及提高性能、降低开发维护成本等原因，同时，更方便企业用户更精准的选择合适的版本产品用于自己的企业生产环境中，MySQL在发展到5.1系列版本之后，重新规划为三条产品线。
　　　　第一条：5.0.xx 到 5.1.xx产品线系列介绍
　　　　第二条：5.4.xx 到 5.7.xx产品线系列介绍(主流：5.5和5.6)
　　　　第三条：6.0.xx 到 7.1.xx产品线系列介绍

　　**MySQL数据库软件命名介绍**

　　　　以mysql-5.6.42.tar.gz的版本号来解释：
　　　　　　1.第一个数字5是主版本号，描述了文件格式。所有版本5发行都有相同的文件格式。
　　　　　　2.第二个数字6是发行级别。主版本号和发行级别组合到一起便构成了发行序列号。
　　　　　　3.第三个数据42是在此发行系列的版本号，随每个新发布版递增。通常你需要已经选择发行的最新版本，每次更新后，版本字符串的最后一个数字会递增。如果增加了一些新功能或者微小的不兼容性，版本字符串的第二个数字会递增。如果文件格式改变，第一个数字会递增。
　　　　一般有的版本也会加上上面我们说的4个版本的后缀，beta、alpha、rc版、ga版等等，我们举得这个例子是不带后缀的，就相当于GA版

 

　　**MySQL版本选择建议**
　　　　1.稳定版：选择开源的社区版的稳定版GA版本
　　　　2.产品线：可以选择5.1、5.5、5.6，互联网公司主流5.5和5.6，其次是5.1.
　　　　3.选择MySQL数据库GA版发布后6个月以上的GA版本。
　　　　4.要选择前后几个月没有大的BUG修复的版本，而不是大量修复BUG的集中版本
　　　　5.最好向后较长时间没有更新发布的版本。
　　　　6.开发、测试、运维、DBA进行自己本地测试的时候，最好要和线上的版本一致，最差也要兼容，所以作为开发，你要清楚公司用的哪个版本的数据库
　　　　7.作为内部开发测试数据库环境，跑大概3-6个月的时间。
　　　　8.优先企业非核心业务采用新版本的数据库GA版本的软件。
　　　　10.向DBA高手请教，或者在技术氛围好的群里和大家一起交流，使用真正高手用过的好用的GA版本产品


　　　　经过上述工序后，若没有重要的功能BUG或者性能瓶颈，则可以开始考虑作为任何业务数据服务的后端数据库软件。



#### 2. MySQL的下载安装、简单应用及目录介绍

​    

- MySQL下载安装                                 
- MySQL安装目录介绍
- root用户密码设置及忘记密码的解决方法
- 修改字符集编码

**1. MySQL下载安装**

mysql下载地址：https://dev.mysql.com/downloads，如果你在mysql官网下载的是zip压缩包，看操作：

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106181042732-1239176965.png)

 

 　　然后按照下面的选择来下载，发现是zip压缩包对吧，zip压缩包解压之后就能用，上面的msi还需要安装一下，安装的时候可以选择很多的依赖环境一起安装：

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106181519322-710415639.png)

　　　　点击download进来：

 　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106183332908-748263188.png)

 

　　下载完成以后进行安装：

　　　　1.  解压MySQL压缩包，将以下载的MySQL压缩包解压到自定义目录下。我放在D:\Program Files\MySQL\ 

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181106182653007-1995817181.png)

　　　　2. 解压完成之后其实就可以用了，但是为了方便使用，也就是在cmd启动mysql的时候，就不用加上全路径了，所以添加一下环境变量，将bin这个文件夹添加到环境变量，bin这个文件夹中有mysqld服务端，有mysql自带的一个客户端，所以添加了环境变量之后，在cmd中直接就可以使用了。

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107093347496-1586487416.png)

　　　　

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107093516080-375853172.png)

　　　　这样就将我们的mysql服务端（mysqld）和mysql自带的一个客户端（供用户在本机测试用的，也是cmd窗口下使用的，客户端叫做mysql，后面操作的时候会使用到）

　　　　然后我们直接在cmd窗口就可以启动mysql服务端了，并且可以在任务管理起里面查看。

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107094044839-1331111074.png)

　　　　然后我们再启动一个cmd窗口来使用一下mysql客户端，然后连接一下我们开启的服务端，就可以成功了。

　　　　连接指令是：mysql -h 服务端IP地址 -P(大写) 3306(mysql服务端默认端口) -uroot（用户，这里我使用root用户来测了） -p密码  。注意：如果这样直接输入密码的话，密码和前面的-p中间不要有空格。

　　　　我自己在本机进行测试的，所以我写的mysql服务端的IP地址为我本机的回环地址127.0.0.1，其实如果是自己测试本机的mysql服务端，我们可以不用写ip地址和端口的，直接写mysql -uroot -p，但是连接别的电脑的mysql的时候一定要写IP地址和端口，并且不能用root用户去远程连接别的电脑的mysql服务端，并且要注意mysql服务器上的防火墙是否允许3306能够被外人连接，如果想让别人连，要更改防火墙设置，让他允许3306端口被连接，或者直接关闭防火墙（不建议直接关闭，测试的时候可以用），否则会报错。

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107095700814-1034376446.png)

　　　　ip地址除了写127.0.0.1之外，还可以写localhost，或者自己本机的ip地址，但是写本机的ip地址的时候，服务端会将你的客户端视为外部设备，不允许你这样登陆。

　　　　自己本机测试连接的时候，完全可以不用写ip地址和端口

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107121939904-1157455480.png)

 

　　　　到目前为止，我们就已经可以连接并使用mysql数据库了，但是你发现，关闭mysql服务端比较麻烦，启动的时候我们直接输入的mysqld回车就启动了

　　　　关闭的方式有两种：

　　　　　　1.通过任务管理器来关闭服务端：

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107115409540-816241190.png)

　　　　　　2.通过cmd指令来关闭mysql服务端

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107115718983-1345248118.png)

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107115853163-1563552706.png)

 

　　　　所以我们可以通过系统服务的方式来控制mysql服务的开启或者关闭，那么就需要将mysql服务加入到系统服务中，来看一下怎么制作成系统服务：

　　　　　　　　打开cmd窗口，注意：必须以管理员身份打开cmd窗口，在左下角的地方找到这个圆圈，点击，然后输入cmd，匹配出来命令提示符，然后右键点击，以管理员身份打开

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122124613-2043235417.png)

 

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122054995-190141479.png)

 　　　　　　　　然后输入 mysqld --install  服务名（可以给这个服务一个名字，直接跟在这个指令的后面，不写也可以，会默认有一个，后面可以查看到）

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122246218-376963589.png)

　　　　　　　　这样就添加系统服务了

　　　　　　　　然后win键+r   打开运行窗口，里面输入services.msc来打开系统服务列表

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122337127-1996408189.png)

　　　　　　　　就可以看到mysqld服务了，如果没有就点击上面的刷新按钮

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122507682-255418311.png)

　　　　　　　　选中MySQL服务这一项，我们就可以直接右键查看功能，功能里面有启动和关闭，就可以通过系统服务的形式来启动和关闭MySQL服务了，这个服务是默认开启的，我们也可以自行设置是否自动开机启动等等的行为，左键双击一下这个服务你就看到下面的窗口了。

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107122707789-81902194.png)

　　　　　　　　

　　　　　　添加了系统服务以后，我们在启动和关闭这个mysql服务，就可以在cmd窗口下使用两个指令就搞定了：

　　　　　　启动指令：net start mysql

　　　　　　关闭指令：net stop mysql

　　　　　　并且不能再使用 mysqld指令直接启动了。

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107152654575-192812430.png)

　　　　　　还可以通过指令来移除刚才添加的系统服务：

　　　　　　　　cmd下移除服务命令为：mysqld remove



​	mysql**安装简单总结**

```shell
#1、下载：MySQL Community Server 5.7.16
http://dev.mysql.com/downloads/mysql/

#2、解压
如果想要让MySQL安装在指定目录，那么就将解压后的文件夹移动到指定目录，如：C:\mysql-5.7.16-winx64

#3、添加环境变量
【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --> 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】
 
#4、初始化
mysqld --initialize-insecure

#5、启动MySQL服务
mysqld # 启动MySQL服务

#6、启动MySQL客户端并连接MySQL服务
mysql -u root -p # 连接MySQL服务器

#7、将mysql添加系统服务
    注意：--install前，必须用mysql启动命令的绝对路径
    # 制作MySQL的Windows服务，在终端执行此命令：
    "c:\mysql-5.7.16-winx64\bin\mysqld" --install
 
    # 移除MySQL的Windows服务，在终端执行此命令：
    "c:\mysql-5.7.16-winx64\bin\mysqld" --remove

    注册成服务之后，以后再启动和关闭MySQL服务时，仅需执行如下命令：
    # 启动MySQL服务
    net start mysql
 
    # 关闭MySQL服务
    net stop mysql
```



**2. MySQL安装目录介绍**



![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181109102923996-996317799.png)

其中，我们重点看一下data文件夹：如果你找不到自己建立的库或者表的文件，可能不在这个data文件夹下面，连接上mysql之后，输入`show global variables like ``"%datadir%"``;来查看数据文件存储路径，找到路径之后，到对应路径下如果找不到这个文件夹，那么可能是隐藏的，把隐藏的文件显示一下就行了。`

![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181109103137038-1513129894.png)

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181109103158055-428480257.png)



​	其中mysql这个库我需要提一下：

​	mysql：这个是mysql整个服务的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。

　　**总结：其实这些库就是我们电脑上对应的文件夹，在mysql中显示为对应的库，来方便我们管理数据，而文件或者文件夹这种与硬盘打交道的事情就交给mysql了，我们只需要对mysql库中的数据进行操作就可以了，你可以看到，我们刚才简单使用的时候创建的一个crm库，也就是在data目录下的生成了一个crm文件夹。**



**3. root用户密码设置及忘记密码的解决方法**

​	**方法1： 用SET PASSWORD命令** 
　　　　首先登录MySQL，使用mysql自带的那个客户端连接上mysql。 
　　　　格式：mysql> set password for 用户名@localhost = password('新密码'); 
　　　　例子：mysql> set password for root@localhost = password('123'); 

　　**方法2：用mysqladmin**  （因为我们将bin已经添加到环境变量了，这个mysqladmin也在bin目录下，所以可以直接使用这个mysqladmin功能，使用它来修改密码）

　　　　关于mysqladmin的介绍：是一个执行管理操作的客户端程序。它可以用来检查服务器的配置和当前状态、创建和删除数据库、修改用户密码等等的功能，虽然mysqladmin的很多功能通过使用MySQL自带的mysql客户端可以搞定，但是有时候使用mysqladmin操作会比较简单。
　　　　格式：mysqladmin -u用户名 -p旧密码 password 新密码 
　　　　例子：mysqladmin -uroot -p123456 password 123 

　　　　只用mysqladmin的时候，会出现一个warning警告信息：Warning: Using a password on the command line interface can be insecure.，这个没关系，是提示你，你直接在cmd下使用明文设置密码的时候，是不安全的，因为别人可以通过翻看你输入指令的历史记录来查看到你设置的密码，所以提示你一下，不信你按上下键，可以看到自己之前输入的命令，或者输入下面这个指令也可以看到：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181107144630827-1405279649.png)

　　　　所以我们最好连接进入到mysql里面之后，在进行密码的修改和设置。
　　**方法3：用UPDATE直接编辑那个自动的mysql库中的user表** 
　　　　首先登录MySQL，连接上mysql服务端。 
　　　　mysql> use mysql;   use mysql的意思是切换到mysql这个库，这个库是所有的用户表和权限相关的表都在这个库里面，我们进入到这个库才能修改这个库里面的表。
　　　　mysql> update user set password=password('123') where user='root' and host='localhost';   其中password=password('123') 前面的password是变量，后面的password是mysql提供的给密码加密用的，我们最好不要明文的存密码，对吧，其中user是一个表，存着所有的mysql用户的信息。

　　　　mysql> flush privileges;  刷新权限，让其生效，否则不生效，修改不成功。



4. **修改字符集编码**

在mysql的安装目录下面创建一个my.ini配置文件(unix系统是my.cnf文件)，文件中写上一下内容：

```shell
[mysqld]
character_set_server=utf8
[client]
default-character-set=utf8
[mysql]
default-character-set=utf8

```

然后重启服务端就可以了。

#### 3. mariadb-10.4.11-winx64.zip安装方法

```shell
# 1. 解压到目标路径如：D:\Tools\mariadb-10.4.11-winx64
# 2. 以管理员身份运行cmd 进入 D:\Tools\mariadb-10.4.11-winx64\bin
# 3. 安装 (mariadb 为服务名，可以自定义)，显示 “Service successfully installed.” 安装成功。
# $ mysqld.exe --install mariadb
$ mysqld.exe --install
# 创建系统数据库和配置文件（可重复执行，会删除以存在文件）
$ mysql_install_db.exe

# 4. 可选择将服务修改成手动启动
# 5. 启动服务
net start mysql

# 6. 增加化境变量
# D:\Tools\mariadb-10.4.11-winx64\bin

# 7. 密码操作
# 设置密码
mysqladmin password 123456
# 修改密码
mysqladmin -uroot -p123456 password 456789

# 8. 修改数据库数据路径和日志路径
# 关闭服务
# 将数据文件移动当目标路径

# 编辑配置文件my.ini 在[mysqld]下写入
# datadir=D:/Temp/mariadb
# log-bin=D:/Temp/mariadb/aria_log

# 启动服务
# 观察目标目录是否有日志文件生成
```





## 第二节 MySQL库表详细操作

#### 本节具体内容如下：        

1. **创建数据库**
2. **数据库相关操作**      
3. **数据表相关操作**	

#### **1.创建数据库**

　　　　**语法**

　　　　　　CREATE DATABASE 数据库名 charset utf8;

　　　　**数据库命名规则**

　　　　　　可以由字母、数字、下划线、＠、＃、＄

　　　　　　区分大小写

　　　　　　唯一性

　　　　　　不能使用关键字如 create select

　　　　　　不能单独使用数字

　　　　　　最长128位



#### **2.数据库相关操作**

```mysql
1 查看数据库
show databases;
show create database db1;
select database();

2 选择数据库
USE 数据库名

3 删除数据库
DROP DATABASE 数据库名;

4 修改数据库
alter database db1 charset utf8;
```

​	关于库的内容，咱们就说这些吧，哈哈，有点少是吧，不是咱们的重点，来看下面的表操作~~~

#### 3.数据表相关操作

**1.存储引擎**

​	**存储引擎介绍**

　　　　存储引擎即表类型，mysql根据不同的表类型会有不同的处理机制。

首先确定一点，存储引擎的概念是MySQL里面才有的，不是所有的关系型数据库都有存储引擎这个概念，后面我们还会说，但是现在要确定这一点。　　

　　在讲清楚什么是存储引擎之前，我们先来个比喻，我们都知道录制一个视频文件，可以转换成不同的格式，例如mp4，avi，wmv等，而存在我们电脑的磁盘上也会存在于不同类型的文件系统中如windows里常见的ntfs、fat32，存在于linux里常见的ext3，ext4，xfs，但是，给我们或者用户看懂实际视频内容都是一样的。直观区别是，占用系统的空间大小与清晰程度可能不一样。
那么数据库表里的数据存储在数据库里及磁盘上和上述的视频格式及存储磁盘文件的系统格式特征类似，也有很多种存储方式。
　　但是对于用户和应用程序来说同样一张表的数据，无论用什么引擎来存储，用户能够看到的数据是一样的。不同储引擎存取，引擎功能，占用空间大小，读取性能等可能有区别。说白了，存储引擎就是在如何存储数据、提取数据、更新数据等技术方法的实现上，底层的实现方式不同，那么就会呈现出不同存储引擎有着一些自己独有的特点和功能，对应着不同的存取机制。
　　因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型(即：对表的存储、操作等的实现方法不同)，表是什么，表本质上就是磁盘上的文件。

　　其实MySQL支持多种存储引擎，每种引擎有着一些自己独特的功能，用户在使用的时候，可以根据自己的业务场景来使用不同的存储引擎，其中MySQL最常用的存储引擎为：MyISAM和InnoDB。
在详细介绍这些存储引擎之前，我们先来看看MySQL的整个工作流程，看一下存储引擎在哪里，MySQL都做了哪些事情。

　　看下图：这是我在MySQL官方手册上拿下来的(手册你如果能够玩好，将来你就能做一个NB的DBA~~~)

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113174617661-1844607042.png)

　　英文版的看着很难受啊超哥，好好好，给你来个中文的，看下图：

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113174704948-1194459622.png)

　　来，看每个部分的解释，看下图：

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113182706498-379601585.png)

　　搞明白整个过程之后，我们来细说一下这些存储引擎。



​	MySQL**存储引擎分类**

前面我们对MySQL进行操作的时候并没有指定存储引擎，为什么还能用呢，没有指定还能用，说明什么，说明MySQL默认有一个存储引擎，我记得MySQL5.5之前，默认的存储引擎是MyISAM，之后都改为InnoDB了，我们的重点就是这个InnoDB，也是公司中最常用的、最好用的引擎，但是还是一些公司在用MyISAM引擎，除了历史原因之外，还有MyISAM的效率比InnoDB高一点，InnoDB在这方面做了很多优化，效率已经和MyISAM差不多了，但是InnoDB引擎还有好多其他的NB的功能，下面我们就介绍几种存储引擎。

　　首先看一下咱们的默认存储引擎：

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113183450654-1661588333.png)

　　

　　不同的引擎代表着不同的存取机制，那么有哪些引擎呢，连接进入mysql之后，查看MySQL支持的所有存储引擎：

　　　　1、show engines；#查看MySQL所有的引擎，

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113184807373-247683719.png)

 

　　　　2、show variables like "storage_engine%";查看当前正在使用的引擎

 　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181113184606683-2116012923.png)

　　　　注意：在存储大文件的时候，可以存到数据库，但是尽量别直接存到数据库里面，会影响数据库的效率，我们就存文件的路径、地址，用户想要这个大文件，我们可以到对应的路径下取读取这个文件给用户。

​	**常见的两种存储引擎介绍**

​	**MyISAM引擎**

```
MyISAM引擎特点：
        1.不支持事务
            事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全成功要么全失败。
        2.表级锁定
            数据更新时锁定整个表：其锁定机制是表级锁定，也就是对表中的一个数据进行操作都会将这个表锁定，其他人不能操作这个表，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能。
        3.读写互相阻塞
            不仅会在写入的时候阻塞读取，MyISAM还会再读取的时候阻塞写入，但读本身并不会阻塞另外的读。
        4.只会缓存索引
            MyISAM可以通过key_buffer_size的值来提高缓存索引，以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据。
        
        5.读取速度较快
            占用资源相对较少
        6.不支持外键约束。
        7.支持全文索引。
        7.MyISAM引擎是MySQL5.5版本之前的默认引擎，是对最初的ISAM引擎优化的产物。
```

​	**InnoDB引擎**

```
InnoDB引擎
        介绍：InnoDB引擎是MySQL数据库的另一个重要的存储引擎，正称为目前MySQL AB（MySQL AB是由MySQL创始人和主要开发人创办的公司）所发行新版的标准，被包含在所有二进制安装包里。和其他的存储引擎相比，InnoDB引擎的优点是支持兼容ACID（原子性（Atomicity[ˌætəˈmɪsəti]）、一致性（Consistency [kənˈsɪstənsi]）、隔离性（Isolation[ˌaɪsəˈleɪʃn]）、持久性（Durability[dərəˈbɪlɪti]））的事务(类似于PostGreSQL)，以及参数完整性(即对外键的支持)。Oracle公司与2005年10月收购了Innobase。Innobase采用双认证授权。它使用GNU发行，也允许其他想将InnoDB结合到商业软件的团体获得授权。

InnoDB引擎特点：
        1.支持事务：支持4个事务隔离级别，支持多版本读。
        更多参阅https://www.cnblogs.com/limuzi1994/p/9684083.html
        2.行级锁定(更新时一般是锁定当前行)：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响。
        更多参阅https://blog.csdn.net/zcl_love_wx/article/details/82382582
        3.读写阻塞与事务隔离级别(有多个级别，这就不介绍啦~)。
        4.具有非常高效的缓存特性：能缓存索引，也能缓存数据。
        5.整个表和主键以Cluster[ˈklʌstər]（聚簇）方式存储，组成一颗平衡树。(了解)
        6.所有SecondaryIndex（二级索引，非聚簇索引）都会保存主键信息。(了解)
        7.支持分区，表空间，类似oracle数据库。
        8.支持外键约束，不支持全文索引(5.5之前)，以后的都支持了。
        9.和MyISAM引擎比较，InnoDB对硬件资源要求还是比较高的。
        
        小结：三个重要功能：Supports transactions（支持事务处理），row-level locking（行级锁），and foreign keys（外键）
```

**事务介绍**

```
事务介绍：
        简单地说，事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。
        例如：你给我转账5块钱，流程如下
            a.从你银行卡取出5块钱，剩余计算money-5
            b.把上面5块钱打入我的账户上，我收到5块，剩余计算money+5.
        上述转账的过程，对应的sql语句为：
                update 你_account set money=money-5 where name='你'；
                update 我_account set money=money+5 where name='我'；
        上述的两条SQL操作，在事务中的操作就是要么都执行，要么都不执行，不然钱就对不上了。
        这就是事务的原子性(Atomicity)。
    事务的四大特性：
        1.原子性(Atomicity)
            事务是一个不可分割的单位，事务中的所有SQL等操作要么都发生，要么都不发生。
        2.一致性(Consistency)
            事务发生前和发生后，数据的完整性必须保持一致。
        3.隔离性(Isolation)
            当并发访问数据库时，一个正在执行的事务在执行完毕前，对于其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。也就是其他人的操作在这个事务的执行过程中是看不到这个事务的执行结果的，也就是他们拿到的是这个事务执行之前的内容，等这个事务执行完才能拿到新的数据。
        4.持久性(Durability)
            一个事务一旦被提交，它对数据库中的数据改变就是永久性的。如果出了错误，事务也不允撤销，只能通过'补偿性事务'。
        
    事务的开启：
        数据库默认事务是自动提交的，也就是发一条sql他就执行一条。如果想多条sql放在一个事务中执行，则需要使用事务进行处理。当我们开启一个事务，并且没有提交，mysql会自动回滚事务。或者我们使用rollback命令手动回滚事务。
        数据库开启事务的命令，我们后面会讲到~~~
```

​	其他引擎介绍

```
#NDB 存储引擎
2003 年,MySQL AB 公司从 Sony Ericsson 公司收购了 NDB 存储引擎。 NDB 存储引擎是一个集群存储引擎,类似于 Oracle 的 RAC 集群,不过与 Oracle RAC 的 share everything 结构不同的是,其结构是 share nothing 的集群架构,因此能提供更高级别的 高可用性。NDB 存储引擎的特点是数据全部放在内存中(从 5.1 版本开始,可以将非索引数据放在磁盘上),因此主键查找(primary key lookups)的速度极快,并且能够在线添加 NDB 数据存储节点(data node)以便线性地提高数据库性能。由此可见,NDB 存储引擎是高可用、 高性能、高可扩展性的数据库集群系统,其面向的也是 OLTP （On-Line Transaction Processing联机事务处理过程）的数据库应用类型。

#Memory 存储引擎
正如其名,Memory 存储引擎中的数据都存放在内存中,数据库重启或发生崩溃,表中的数据都将消失。它非常适合于存储 OLTP 数据库应用中临时数据的临时表,也可以作为 OLAP （联机分析处理）数据库应用中数据仓库的维度表。Memory 存储引擎默认使用哈希 索引,而不是通常熟悉的 B+ 树索引。

#Infobright 存储引擎
第三方的存储引擎。其特点是存储是按照列而非行的,因此非常 适合 OLAP 的数据库应用。其官方网站是 http://www.infobright.org/,上面有不少成功的数据 仓库案例可供分析。

#NTSE 存储引擎
网易公司开发的面向其内部使用的存储引擎。目前的版本不支持事务, 但提供压缩、行级缓存等特性,不久的将来会实现面向内存的事务支持。

#BLACKHOLE
黑洞存储引擎，可以应用于主备复制中的分发主库。

MySQL 数据库还有很多其他存储引擎,上述只是列举了最为常用的一些引擎。如果 你喜欢,完全可以编写专属于自己的引擎,这就是开源赋予我们的能力,也是开源的魅 力所在。
```



**引擎简单使用**

1、创建表时指定引擎

```mysql
create table innodb_t2(id int)engine=innodb;
```

2、在配置文件中指定默认的存储引擎

```shell
linux:vim /etc/my.cnf   windows:my.ini文件
[mysqld]
default-storage-engine=INNODB  #配置默认引擎，现在用的mysql默认基本都是InnoDB，所以其实都可以不用配置了
innodb_file_per_table=1  #表示独立表空间存储，可以不写
```

3、不同引擎在创建表的时候生成文件的不同

​	创建四个表，分别使用innodb，myisam，memory，blackhole存储引擎，进行插入数据测试

```mysql
#下面是使用四个不同的引擎来创建的表
create table t1(id int)engine=innodb;
create table t2(id int)engine=myisam;
create table t3(id int)engine=memory;
create table t4(id int)engine=blackhole;
```

通过四种引擎来创建的表，我们对照着其生成的文件来看一下区别，看下图：

　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181114114754297-1522063600.png)





**2.表介绍**

 　　　　表相当于文件，表中的一条记录就相当于文件的一行内容，表中的一条记录有对应的标题，称为表的字段

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181114155542258-1500963336.png)

　　　　第一行的id、name2、age是字段，其余的，一行内容称为一条记录。

**3.创建表**

**3.1 建表语法**　　　　

```mysql
#语法：
create table 表名(
字段名1 类型[(宽度) 约束条件],
字段名2 类型[(宽度) 约束条件],
字段名3 类型[(宽度) 约束条件]
);

#注意：
1. 在同一张表中，字段名是不能相同
2. 宽度和约束条件可选、非必须，宽度指的就是字段长度约束，例如：char(10)里面的10
3. 字段名和类型是必须的
```

示例代码

```mysql
mysql> create database db1 charset utf8;

mysql> use db1;

mysql> create table t1(  
    -> id int, 
    -> name varchar(50),
    -> sex enum('male','female'),
    -> age int(3)
    -> );

mysql> show tables; #查看db1库下所有表名

mysql> desc t1;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type                  | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id    | int(11)               | YES  |     | NULL    |       |
| name  | varchar(50)           | YES  |     | NULL    |       |
| sex   | enum('male','female') | YES  |     | NULL    |       |
| age   | int(3)                | YES  |     | NULL    |       |
+-------+-----------------------+------+-----+---------+-------+

mysql> select id,name,sex,age from t1;
Empty set (0.00 sec)

mysql> select * from t1;
Empty set (0.00 sec)

mysql> select id,name from t1;
Empty set (0.00 sec)
```

插入数据

```mysql
mysql> insert into t1 values
    -> (1,'chao',18,'male'),
    -> (2,'sb',81,'female')
    -> ;
mysql> select * from t1;
+------+------+------+--------+
| id   | name | age  | sex    |
+------+------+------+--------+
|    1 | chao |   18 | male   |
|    2 | sb |   81 | female |
+------+------+------+--------+



mysql> insert into t1(id) values 
    -> (3),
    -> (4);
mysql> select * from t1;
+------+------+------+--------+
| id   | name | age  | sex    |
+------+------+------+--------+
|    1 | chao |   18 | male   |
|    2 | sb |   81 | female |
|    3 | NULL | NULL | NULL   |
|    4 | NULL | NULL | NULL   |
+------+------+------+--------+
```



**4.查看表结构**

```mysql
mysql> describe t1; #查看表结构，可简写为：desc 表名
+-------+-----------------------+------+-----+---------+-------+
| Field | Type                  | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| id    | int(11)               | YES  |     | NULL    |       |
| name  | varchar(50)           | YES  |     | NULL    |       |
| sex   | enum('male','female') | YES  |     | NULL    |       |
| age   | int(3)                | YES  |     | NULL    |       |
+-------+-----------------------+------+-----+---------+-------+


mysql> show create table t1\G; #查看表详细结构，可加\G
```



**5.MySQL的基础数据类型**

数值类型

```
1、整数类型

　　　　整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT

　　　　作用：存储年龄，等级，id，各种号码等
```

对于整型来说，数据类型后面的宽度并不是存储长度限制，而是显示限制，假如：int(8)，那么显示时不够8位则用0来填充，够8位则正常显示，通过zerofill来测试，存储长度还是int的4个字节长度。默认的显示宽度就是能够存储的最大的数据的长度，比如：int无符号类型，那么默认的显示宽度就是int(10)，有符号的就是int(11)，因为多了一个符号，所以我们没有必要指定整数类型的数据，没必要指定宽度，因为默认的就能够将你存的原始数据完全显示

​	　![img](https://images2017.cnblogs.com/blog/1036857/201708/1036857-20170801181433755-146301178.png)

　　　　int的存储宽度是4个Bytes，即32个bit，即2**32　　

　　　　无符号最大值为：4294967296-1

　　　　有符号最大值：2147483648-1

　　　　有符号和无符号的最大数字需要的显示宽度均为10，而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的

　　　　最后：整形类型，其实没有必要指定显示宽度，使用默认的就ok

浮点型

　　　　定点数类型  DEC，等同于DECIMAL　　  [ˈdesɪml] 十进制的

　　　　浮点类型：FLOAT DOUBLE

　　　　作用：存储薪资、身高、温度、体重、体质参数等

```
1.FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]

    定义：
            单精度浮点数（非准确小数值），m是整数部分+小数部分的总个数，d是小数点后个数。m最大值为255，d最大值为30，例如：float(255,30)

    有符号：
               -3.402823466E+38 to -1.175494351E-38,
               1.175494351E-38 to 3.402823466E+38
    无符号：
               1.175494351E-38 to 3.402823466E+38


    精确度： 
               **** 随着小数的增多，精度变得不准确 ****



2.DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]

    定义：
               双精度浮点数（非准确小数值），m是整数部分+小数部分的总个数，d是小数点后个数。m最大值也为255，d最大值也为30

    有符号：
               -1.7976931348623157E+308 to -2.2250738585072014E-308
               2.2250738585072014E-308 to 1.7976931348623157E+308

    无符号：
               2.2250738585072014E-308 to 1.7976931348623157E+308
                
    精确度：
               ****随着小数的增多，精度比float要高，但也会变得不准确 ****


3.decimal[(m[,d])] [unsigned] [zerofill]   	decimal：[ˈdesɪml] 

    定义：
              准确的小数值，m是整数部分+小数部分的总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。比float和double的整数个数少，但是小数位数都是30位


    精确度：
               **** 随着小数的增多，精度始终准确 ****
               对于精确数值计算时需要用此类型
               decimal能够存储精确值的原因在于其内部按照字符串存储。
精度从高到低：decimal、double、float
    decimal精度高，但是整数位数少
    float和double精度低，但是整数位数多
float已经满足绝大多数的场景了，但是什么导弹、航线等要求精度非常高，所以还是需要按照业务场景自行选择，如果又要精度高又要整数位数多，那么你可以直接用字符串来存。
```

**浮点型测试**

```mysql
mysql> create table t1(x float(256,31));
ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30.
mysql> create table t1(x float(256,30));
ERROR 1439 (42000): Display width out of range for column 'x' (max = 255)
mysql> create table t1(x float(255,30)); #建表成功
Query OK, 0 rows affected (0.02 sec)

mysql> create table t2(x double(255,30)); #建表成功
Query OK, 0 rows affected (0.02 sec)

mysql> create table t3(x decimal(66,31));
ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30.
mysql> create table t3(x decimal(66,30));
ERROR 1426 (42000): Too-big precision 66 specified for 'x'. Maximum is 65.
mysql> create table t3(x decimal(65,30)); #建表成功
Query OK, 0 rows affected (0.02 sec)

mysql> show tables;
+---------------+
| Tables_in_db1 |
+---------------+
| t1            |
| t2            |
| t3            |
+---------------+
3 rows in set (0.00 sec)



mysql> insert into t1 values(1.1111111111111111111111111111111); #小数点后31个1
Query OK, 1 row affected (0.01 sec)

mysql> insert into t2 values(1.1111111111111111111111111111111);
Query OK, 1 row affected (0.00 sec)

mysql> insert into t3 values(1.1111111111111111111111111111111);
Query OK, 1 row affected, 1 warning (0.01 sec)

mysql> select * from t1; #随着小数的增多，精度开始不准确
+----------------------------------+
| x                                |
+----------------------------------+
| 1.111111164093017600000000000000 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> select * from t2; #精度比float要准确点，但随着小数的增多，同样变得不准确
+----------------------------------+
| x                                |
+----------------------------------+
| 1.111111111111111200000000000000 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> select * from t3; #精度始终准确,d为30，于是只留了30位小数
+----------------------------------+
| x                                |
+----------------------------------+
| 1.111111111111111111111111111111 |
+----------------------------------+
1 row in set (0.00 sec)
```



日期类型

类型：DATE，TIME，DATETIME ，TIMESTAMP( [taɪm] [stæmp])，YEAR 

作用：存储用户注册时间，文章发布时间，员工入职时间，出生时间，过期时间等

```
		YEAR
            YYYY（范围：1901/2155）2018

        DATE
            YYYY-MM-DD（范围：1000-01-01/9999-12-31）例：2018-01-01 

        TIME
            HH:MM:SS（范围：'-838:59:59'/'838:59:59'）例：12:09:32

        DATETIME

            YYYY-MM-DD HH:MM:SS（范围：1000-01-01 00:00:00/9999-12-31 23:59:59    Y）例： 2018-01-01 12:09:32

        TIMESTAMP

            YYYYMMDD HHMMSS（范围：1970-01-01 00:00:00/2037 年某时）
```

**日期类型测试**

```mysql
year：
    mysql> create table t10(born_year year); #无论year指定何种宽度，最后都默认是year(4)
    mysql> insert into t10 values  
        -> (1900),
        -> (1901),
        -> (2155),
        -> (2156);
    mysql> select * from t10;
    +-----------+
    | born_year |
    +-----------+
    |      0000 |
    |      1901 |
    |      2155 |
    |      0000 |
    +-----------+


date,time,datetime:
    mysql> create table t11(d date,t time,dt datetime);
    mysql> desc t11;
    +-------+----------+------+-----+---------+-------+
    | Field | Type     | Null | Key | Default | Extra |
    +-------+----------+------+-----+---------+-------+
    | d     | date     | YES  |     | NULL    |       |
    | t     | time     | YES  |     | NULL    |       |
    | dt    | datetime | YES  |     | NULL    |       |
    +-------+----------+------+-----+---------+-------+

    mysql> insert into t11 values(now(),now(),now());
    mysql> select * from t11;
    +------------+----------+---------------------+
    | d          | t        | dt                  |
    +------------+----------+---------------------+
    | 2017-07-25 | 16:26:54 | 2017-07-25 16:26:54 |
    +------------+----------+---------------------+



timestamp：
    mysql> create table t12(time timestamp);
    mysql> insert into t12 values();
    mysql> insert into t12 values(null);
    mysql> select * from t12;
    +---------------------+
    | time                |
    +---------------------+
    | 2017-07-25 16:29:17 |
    | 2017-07-25 16:30:01 |
    +---------------------+



============注意啦，注意啦，注意啦===========
    1. 单独插入时间时，需要以字符串的形式，按照对应的格式插入
    2. 插入年份时，尽量使用4位值
    3. 插入两位年份时，<=69，以20开头，比如50,  结果2050      
                    >=70，以19开头，比如71，结果1971
    mysql> create table t12(y year);
    mysql> insert into t12 values  
        -> (50),
        -> (71);
    mysql> select * from t12;
    +------+
    | y    |
    +------+
    | 2050 |
    | 1971 |
    +------+



============综合练习===========
    mysql> create table student(
        -> id int,
        -> name varchar(20),
        -> born_year year,
        -> birth date,
        -> class_time time,
        -> reg_time datetime);

    mysql> insert into student values
        -> (1,'sb1',"1995","1995-11-11","11:11:11","2017-11-11 11:11:11"),
        -> (2,'sb2',"1997","1997-12-12","12:12:12","2017-12-12 12:12:12"),
        -> (3,'sb3',"1998","1998-01-01","13:13:13","2017-01-01 13:13:13");  

    mysql> select * from student;
    +------+------+-----------+------------+------------+---------------------+
    | id   | name | born_year | birth      | class_time | reg_time            |
    +------+------+-----------+------------+------------+---------------------+
    |    1 | sb1 |      1995 | 1995-11-11 | 11:11:11   | 2017-11-11 11:11:11 |
    |    2 | sb2 |      1997 | 1997-12-12 | 12:12:12   | 2017-12-12 12:12:12 |
    |    3 | sb3 |      1998 | 1998-01-01 | 13:13:13   | 2017-01-01 13:13:13 |
    +------+------+-----------+------------+------------+---------------------+

```

字符串类型

​	类型：char，varchar

　　作用：名字，信息等等

```
#官网：https://dev.mysql.com/doc/refman/5.7/en/char.html
#注意：char和varchar括号内的参数指的都是字符的长度

#char类型：定长，简单粗暴，浪费空间，存取速度快
    字符长度范围：0-255（一个中文是一个字符，是utf8编码的3个字节）
    存储：
        存储char类型的值时，会往右填充空格来满足长度
        例如：指定长度为10，存>10个字符则报错(严格模式下)，存<10个字符则用空格填充直到凑够10个字符存储

    检索：
        在检索或者说查询时，查出的结果会自动删除尾部的空格，如果你想看到它补全空格之后的内容，除非我们打开pad_char_to_full_length SQL模式（SET sql_mode = 'strict_trans_tables,PAD_CHAR_TO_FULL_LENGTH';）

#varchar类型：变长，精准，节省空间，存取速度慢
    字符长度范围：0-65535（如果大于21845会提示用其他类型 。mysql行最大限制为65535字节，字符编码为utf-8：https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html）
    存储：
        varchar类型存储数据的真实内容，不会用空格填充，如果'ab  ',尾部的空格也会被存起来
        强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用）
        如果真实的数据<255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255）
        如果真实的数据>255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535）
    
    检索：
        尾部有空格会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容

```

**char和varchar性能对比：**
　　　　以char(5)和varchar(5)来比较，加入我要存三个人名：sb，ssb1，ssbb2
　　　　**char：**
　　　　　　优点：简单粗暴，不管你是多长的数据，我就按照规定的长度来存，5个5个的存，三个人名就会类似这种存储：sb ssb1 ssbb2，中间是空格补全，取数据的时候5个5个的取，简单粗暴速度快
　　　　　　缺点：貌似浪费空间，并且我们将来存储的数据的长度可能会参差不齐

　　　　**varchar：**
　　　　　　varchar类型不定长存储数据，更为精简和节省空间
　　　　　　例如存上面三个人名的时候类似于是这样的：sbssb1ssbb2，连着的，如果这样存，请问这三个人名你还怎么取出来，你知道取多长能取出第一个吗？(超哥，我能看出来啊，那我只想说：滚犊子！)
　　　　　　不知道从哪开始从哪结束，遇到这样的问题，你会想到怎么解决呢？还记的吗？想想？socket？tcp？struct？把数据长度作为消息头。


　　　　　　所以，varchar在存数据的时候，会在每个数据前面加上一个头，这个头是1-2个bytes的数据，这个数据指的是后面跟着的这个数据的长度，1bytes能表示2**8=256，两个bytes表示2**16=65536，能表示0-65535的数字，所以varchar在存储的时候是这样的：1bytes+sb+1bytes+ssb1+1bytes+ssbb2，所以存的时候会比较麻烦，导致效率比char慢，取的时候也慢，先拿长度，再取数据。

　　　　　　优点：节省了一些硬盘空间，一个acsii码的字符用一个bytes长度就能表示，但是也并不一定比char省，看一下官网给出的一个表格对比数据，当你存的数据正好是你规定的字段长度的时候，varchar反而占用的空间比char要多。

| Value        | `CHAR(4)` | Storage Required | `VARCHAR(4)` | Storage Required |
| ------------ | --------- | ---------------- | ------------ | ---------------- |
| `''`         | `'    '`  | 4 bytes          | `''`         | 1 byte           |
| `'ab'`       | `'ab  '`  | 4 bytes          | `'ab'`       | 3 bytes          |
| `'abcd'`     | `'abcd'`  | 4 bytes          | `'abcd'`     | 5 bytes          |
| `'abcdefgh'` | `'abcd'`  | 4 bytes          | `'abcd'`     | 5 bytes          |

​			缺点：存取速度都慢



**总结：**
　　　　所以需要根据业务需求来选择用哪种类型来存
　　　　其实在多数的用户量少的工作场景中char和varchar效率差别不是很大，最起码给用户的感知不是很大，并且其实软件级别的慢远比不上硬件级别的慢，所以你们公司的运维发现项目慢的时候会加内存、换nb的硬盘，项目的效率提升的会很多，但是我们作为专业人士，我们应该提出来这样的技术点来提高效率。

　　　　但是对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。

　　　　所以啊，两个选哪个都可以，如果是大型并发项目，追求高性能的时候，需要结合你们服务器的硬件环境来进行测试，看一下char和varchar哪个更好，这也能算一个优化的点吧~~~~

　**其他的字符串类型：BINARY、VARBINARY、BLOB、TEXT**

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181115180030793-1819767308.png)

枚举和集合

​	字段的值只能在给定范围中选择，如单选框，多选框，如果你在应用程序或者前端不做选项限制，在MySQL的字段里面也能做限制
　　enum( [ɪˌnuːməˈreɪʃn]枚举) 单选	只能在给定的范围内选一个值，如性别 sex 男male [meɪl]/女female[ˈfiːmeɪl] 
　　set 多选 在给定的范围内可以选择一个或一个以上的值（爱好1,爱好2,爱好3...）

```
		枚举类型（enum）
            An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)
            示例：
                CREATE TABLE shirts (
                    name VARCHAR(40),
                    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
                );
                INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),('polo shirt','small');

  

          集合类型（set）
            A SET column can have a maximum of 64 distinct members.
            示例：
                CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));
                INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
```

​	**测试**

```mysql
 mysql> create table consumer( 
    -> name varchar(50),
    -> sex enum('male','female'),
    -> level enum('vip1','vip2','vip3','vip4','vip5'), #在指定范围内，多选一
    -> hobby set('play','music','read','study') #在指定范围内，多选多
    -> );

    mysql> insert into consumer values  
        -> ('xiaogui','male','vip5','read,study'),
        -> ('taibai','female','vip1','girl');

    mysql> select * from consumer;
    +------+--------+-------+------------+
    | name | sex    | level | hobby      |
    +------+--------+-------+------------+
    | xiaogui | male   | vip5  | read,study |
    | taibai | female | vip1  |            |
    +------+--------+-------+------------+
```

**6.表的完整性约束**

介绍

​	约束条件与数据类型的宽度一样，都是可选参数

　　作用：用于保证数据的完整性和一致性

主要分为

```

PRIMARY KEY (PK)    标识该字段为该表的主键，可以唯一的标识记录 PRIMARY[ˈpraɪmeri] 主要的
FOREIGN KEY (FK)    标识该字段为该表的外键  FOREIGN[ˈfɔːrən] 外国的
NOT NULL    标识该字段不能为空
UNIQUE KEY (UK)    标识该字段的值是唯一的 UNIQUE[juˈniːk] 唯一的
AUTO_INCREMENT    标识该字段的值自动增长（整数类型，而且为主键） INCREMENT[ˈɪŋkrəmənt]增量
DEFAULT    为该字段设置默认值

UNSIGNED 无符号  [ənˈsaɪnd] 
ZEROFILL 使用0填充
```

说明

```
1. 是否允许为空，默认NULL，可设置NOT NULL，字段不允许为空，必须赋值
2. 字段是否有默认值，缺省的默认值是NULL，如果插入记录时不给字段赋值，此字段使用默认值
sex enum('male','female') not null default 'male'
age int unsigned NOT NULL default 20 必须为正值（无符号） 不允许为空 默认是20
3. 是否是key
主键 primary key
外键 foreign key
索引 (index,unique...)
```



not null与default

​	是否可空，null表示空，非字符串
　　not null - 不可空
　　null - 可空

　　

　　默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值
　　create table tb1(
　　　　nid int not null defalut 2,
　　　　num int not null
　　)；

　　先说一点：在我们插入数据的时候，可以这么写insert into tb1(nid，num) values（1，‘chao’）；就是在插入输入的时候，指定字段插入数据，如果我在只给num插入值，可以这样写insert into tb1(num) values('chao');还可以插入数据的时候，指定插入数据字段的顺序：把nid和num换个位置，但是对应插入的值也要换位置。注意：即便是你只给一个字段传值了，**那么也是生成一整条记录**，这条记录的其他字段的值如果可以为空，那么他们就都是null空值，如果不能为空，就会报错。

​	测试

```mysql
==================not null====================
mysql> create table t1(id int); #id字段默认可以插入空
mysql> desc t1;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
mysql> insert into t1 values(); #可以插入空


mysql> create table t2(id int not null); #设置字段id不为空
mysql> desc t2;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | NO   |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
mysql> insert into t2 values(); #不能插入空
ERROR 1364 (HY000): Field 'id' doesn't have a default value



==================default====================
#设置id字段有默认值后，则无论id字段是null还是not null，都可以插入空，插入空默认填入default指定的默认值
mysql> create table t3(id int default 1);
mysql> alter table t3 modify id int not null default 1;



==================综合练习====================
mysql> create table student(
    -> name varchar(20) not null,
    -> age int(3) unsigned not null default 18,
    -> sex enum('male','female') default 'male',
    -> hobby set('play','study','read','music') default 'play,music'
    -> );
mysql> desc student;
+-------+------------------------------------+------+-----+------------+-------+
| Field | Type                               | Null | Key | Default    | Extra |
+-------+------------------------------------+------+-----+------------+-------+
| name  | varchar(20)                        | NO   |     | NULL       |       |
| age   | int(3) unsigned                    | NO   |     | 18         |       |
| sex   | enum('male','female')              | YES  |     | male       |       |
| hobby | set('play','study','read','music') | YES  |     | play,music |       |
+-------+------------------------------------+------+-----+------------+-------+
mysql> insert into student(name) values('chao');
mysql> select * from student;
+------+-----+------+------------+
| name | age | sex  | hobby      |
+------+-----+------+------------+
| chao|  18 | male | play,music |
+------+-----+------+------------+
```

​	**注意一点：如果是非严格模式，int类型不传值的话会默认为0，因为null不是int类型的，字段是int类型，所以他会自动将null变为0**



unique

​	独一无二，唯一属性：id，身份证号等

　　是一种key，唯一键，是在数据类型之外的附加属性，其实还有加速查询的作用，后面再讲这个。

​	创建unique

```mysql
============设置唯一约束 UNIQUE===============
方法一：
create table department1(
id int,
name varchar(20) unique,
comment varchar(100)
);


方法二：
create table department2(
id int,
name varchar(20),
comment varchar(100),
constraint uk_name unique(name)
);


mysql> insert into department1 values(1,'IT','技术');
Query OK, 1 row affected (0.00 sec)
mysql> insert into department1 values(1,'IT','技术');
ERROR 1062 (23000): Duplicate entry 'IT' for key 'name'
```

​	创建联合唯一

```mysql
create table service(
id int primary key auto_increment,
name varchar(20),
host varchar(15) not null,
port int not null,
unique(host,port) #联合唯一
);

mysql> insert into service values
    -> (1,'nginx','192.168.0.10',80),
    -> (2,'haproxy','192.168.0.20',80),
    -> (3,'mysql','192.168.0.30',3306)
    -> ;
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> insert into service(name,host,port) values('nginx','192.168.0.10',80);
ERROR 1062 (23000): Duplicate entry '192.168.0.10-80' for key 'host'
```

primary key

​	从约束角度看primary key字段的值不为空且唯一，那我们直接使用not null+unique不就可以了吗，要它干什么？

　　主键primary key是innodb存储引擎组织数据的依据，innodb称之为索引组织表，一张表中必须有且只有一个主键。　

　　一个表中可以：

　　　　单列做主键
　　　　多列做主键（复合主键或者叫做联合主键）

​	通俗解释：

```
unique key和primary key都是MySQL的特殊类型，不仅仅是个字段约束条件，还称为索引，可以加快查询速度，这个索引功能我们后面再讲，现在只讲一下这些key作为约束条件的效果。

    关于主键的强调内容：
        1.一张表中必须有，并且只能有一个主键字段：innodb引擎下存储表数据的时候，会通过你的主键字段的数据来组织管理所有的数据，将数据做成一种树形结构的数据结构，帮你较少IO次数，提高获取定位数据、获取数据的速度，优化查询。
            解释：如果我们在一张表中没有设置primary key，那么mysql在创建表的时候，会按照顺序从上到下遍历你设置的字段，直到找到一个not null unique的字段，自动识别成主键pri，通过desc可以看到，这样是不是不好啊，所以我们在创建表的时候，要给他一个主键，让他优化的时候用，如果没有pri也没有not null unique字段，那么innodb引擎下的mysql被逼无奈，你没有设置主键字段，主键又有不为空且唯一的约束，又不能擅自给你的字段加上这些约束，那么没办法，它只能给你添加一个隐藏字段来帮你组织数据，如果是这样，你想想，主键是不是帮我们做优化查询用的啊，这个优化是我们可以通过主键来查询数据：例如：如果我们将id设置为主键，当我们查一个id为30的数据的时候，也就是select * from tb1 where id=30；这个查询语句的速度非常快，不需要遍历前面三十条数据，就好像我们使用的字典似的，找一个字，不需要一页一页的翻书，可以首先看目录，然后看在哪一节，然后看在哪一页，一步步的范围，然后很快就找到了，这就像我们说的mysql的索引(主键、唯一键)的工作方式，一步一步的缩小范围来查找，几步就搞定了，所以通过主键你能够快速的查询到你所需要的数据，所以，如果你的主键是mysql帮你加的隐藏的字段，你查询数据的时候，就不能将这个隐藏字段作为条件来查询数据了，就不能享受到优化后的查询速度了，对么
        
        2.一张表里面，通常都应该有一个id字段，而且通常把这个id字段作为主键，当然你非要让其他的字段作为主键也是可以的，看你自己的设计，创建表的时候，一般都会写create table t1(id int primary key);id int primary key这个东西在建表的时候直接就写上
```

在没有设置主键的时候，not null+unique会被默认当成主键

```mysql
mysql> create table t1(id int not null unique);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t1;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | NO   | PRI | NULL    |       |
+-------+---------+------+-----+---------+-------+
1 row in set (0.00 sec)
```

单列主键测试

```mysql
============单列做主键===============
#方法一：not null+unique
create table department1(
id int not null unique, #主键
name varchar(20) not null unique,
comment varchar(100)
);

mysql> desc department1;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| id      | int(11)      | NO   | PRI | NULL    |       |
| name    | varchar(20)  | NO   | UNI | NULL    |       |
| comment | varchar(100) | YES  |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
rows in set (0.01 sec)

#方法二：在某一个字段后用primary key
create table department2(
id int primary key, #主键
name varchar(20),
comment varchar(100)
);

mysql> desc department2;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| id      | int(11)      | NO   | PRI | NULL    |       |
| name    | varchar(20)  | YES  |     | NULL    |       |
| comment | varchar(100) | YES  |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
rows in set (0.00 sec)

#方法三：在所有字段后单独定义primary key
create table department3(
id int,
name varchar(20),
comment varchar(100),
constraint pk_name primary key(id); #创建主键并为其命名pk_name

mysql> desc department3;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| id      | int(11)      | NO   | PRI | NULL    |       |
| name    | varchar(20)  | YES  |     | NULL    |       |
| comment | varchar(100) | YES  |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
rows in set (0.01 sec)
```

联合主键解释

```mysql
联合主键
        和联合唯一是类似的，
        mysql> create table t10(
            ->id int,
            ->port int,
            ->primary key(id,port)
            -> );
        Query OK, 0 rows affected (0.45 sec)

        mysql> desc t10;
        +-------+---------+------+-----+---------+-------+
        | Field | Type    | Null | Key | Default | Extra |
        +-------+---------+------+-----+---------+-------+
        | id    | int(11) | NO   | PRI | 0       |       | 
        | port  | int(11) | NO   | PRI | 0       |       |
        +-------+---------+------+-----+---------+-------+
        2 rows in set (0.10 sec)
      
        看key，两个都写的是pri，两个联合起来作为主键，他们两个作为一个主键，不能再有其他的主键了，也就是在创建表的时候，只能出现一次primary key方法。
        有同学说，老师，我不写primary key行不，只写一个not null unique字段，当然行，但是我们应该这样做吗，是不是不应该啊，所以以后设置主键的时候，就使用primary key来指定
```

多列(联合)主键测试

```mysql
==================多列做主键================
create table service(
ip varchar(15),
port char(5),
service_name varchar(10) not null,
primary key(ip,port)
);


mysql> desc service;
+--------------+-------------+------+-----+---------+-------+
| Field        | Type        | Null | Key | Default | Extra |
+--------------+-------------+------+-----+---------+-------+
| ip           | varchar(15) | NO   | PRI | NULL    |       |
| port         | char(5)     | NO   | PRI | NULL    |       |
| service_name | varchar(10) | NO   |     | NULL    |       |
+--------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> insert into service values
    -> ('172.16.45.10','3306','mysqld'),
    -> ('172.16.45.11','3306','mariadb')
    -> ;
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> insert into service values ('172.16.45.10','3306','nginx');
ERROR 1062 (23000): Duplicate entry '172.16.45.10-3306' for key 'PRIMARY'
```



auto_increment

​	之前我们插入数据的时候，id也需要自己来写，是不是很麻烦啊，我们是不是想，只要有一条记录就直接插入进去啊，不需要考虑说，你现在存储到第多少条数据了，对不对，所以出现了一个叫做auto_increment的属性

　　约束字段为自动增长，被约束的字段必须同时被key约束，也就是说只能给约束成key的字段加自增属性，默认起始位置为1，步长也为1.

auto_increment测试

```mysql
#不指定id，则自动增长
create table student(
id int primary key auto_increment,
name varchar(20),
sex enum('male','female') default 'male'
);

mysql> desc student;
+-------+-----------------------+------+-----+---------+----------------+
| Field | Type                  | Null | Key | Default | Extra          |
+-------+-----------------------+------+-----+---------+----------------+
| id    | int(11)               | NO   | PRI | NULL    | auto_increment |
| name  | varchar(20)           | YES  |     | NULL    |                |
| sex   | enum('male','female') | YES  |     | male    |                |
+-------+-----------------------+------+-----+---------+----------------+
mysql> insert into student(name) values
    -> ('egon'),
    -> ('alex')
    -> ;

mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  1 | egon | male |
|  2 | alex | male |
+----+------+------+


#也可以指定id
mysql> insert into student values(4,'asb','female');
Query OK, 1 row affected (0.00 sec)

mysql> insert into student values(7,'wsb','female');
Query OK, 1 row affected (0.00 sec)

mysql> select * from student;
+----+------+--------+
| id | name | sex    |
+----+------+--------+
|  1 | egon | male   |
|  2 | alex | male   |
|  4 | asb  | female |
|  7 | wsb  | female |
+----+------+--------+


#对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长
mysql> delete from student;
Query OK, 4 rows affected (0.00 sec)

mysql> select * from student;
Empty set (0.00 sec)

mysql> insert into student(name) values('ysb');
mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  8 | ysb  | male |
+----+------+------+

#应该用truncate（ [ˈtrʌŋkeɪt] 截断）清空表，比起delete一条一条地删除记录，truncate是直接清空表，在删除大表时用它
mysql> truncate student;
Query OK, 0 rows affected (0.01 sec)

mysql> insert into student(name) values('egon');
Query OK, 1 row affected (0.01 sec)

mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  1 | egon | male |
+----+------+------+
1 row in set (0.00 sec)

```



foreign key

​	 快速理解foreign key（外键其实就是标明表和表之间的关系，表和表之间如果有关系的话就三种：一对一，多对一，多对多，我们挨个看看~）

　　　　员工信息表有三个字段：工号  姓名  部门

　　　　公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费

　　　　那这就体现出来了三个缺点：

　　　　　　1.表的组织结构不清晰：员工的信息、部门的信息等等都掺在一张表里面。

　　　　　　2.浪费空间，每一条信息都包含员工和部门，多个员工从属一个部门，也需要每个员工的信息里都包含着部门的信息，浪费硬盘空间。

　　　　　　3.扩展性极差：如果想修改一个部门的信息，比如修改部门名称，那么这个包含员工和部门信息的表中的所有的包含这个部门信息的数据都需要进行修改，那么修改起来就非常麻烦，这是非常致命的缺点。

　　　　解决方法：（画一个excel表格来表示一下效果~~）

　　　　　　我们完全可以定义一个部门表，解耦和

　　　　　　我们虽然将部门表提出来了，但是员工表本身是和部门有联系的，你光把部门信息提出来还是不够的，还需要建立关联

　　　　　　然后让员工信息表关联该表，如何关联，即foreign key　

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120134926941-1019804865.png)

 

 　　　　在解释一下：数据要拆到不同表里面存着，你要站在两个表的角度来看两者之间的关系，你站在部门表的角度看，一个部门包含多个员工，站在员工表看，多个员工属于一个部门，以我们上课来举个例子看：现在的多个老师可以讲一个课程python，那么老师对于课程表来说就是多对一个关系，那这是不是就是最终关系呢，我们还需要站在课程表的角度来看，多个课程能不能被一个老师教啊，这个看业务场景，你看咱们学校就不行，讲python的只能讲python，但是我们上的小学，初中，高中是不是多个课程可以被一个老师教啊，所以从老男孩的业务来看，课程表对老师表是一对一的，即便是你多个老师可以讲这一门课程，但是这一门可能对应的那几个老师只能讲这一门，不能讲其他的课程，所以他们只是单纯的多对一的关系，多个老师对应一门课程，但是小学、初中、高中的业务，多个老师可以教一门课程，同样这多个老师每个老师又可以教多门课程，那么从课程表角度来看，多个课程也能从属一个老师，所以是多对多的关系：看下图

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120140818625-1670827769.png)

　　 **一对多的关系**　　

　　　　我们在看看员工和部门这个多对一的关系表：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120144851634-1641860170.png)

　　　　如果我们没有做强制的约束关系，那么在员工表里面那个部门id可以随便写，即便是部门表里面没有这个id号，它也是可以写的，但是这样写就错了，因为业务不允许，并且这个数据完全没用，根本就不存在这个部门，哪里来的这个部门的员工呢，对不对，所以要做一个硬性的关系，你员工里面的部门id一定要来自于部门表的id字段。怎么来做这个硬性关系呢，通过外键foreign key，怎么叫外键，就是跟外部的一个表进行关联，建立这种硬性的关系，就叫做外键，就像我们上面这两个表似的，左边的员工表有一个字段(部门id字段)来自于右边的部门表，那么我们就可以通过数据库在员工表的部门id字段加上一个foreign key，外键关联到右边部门表的id字段，这样就建立了这种硬性的关系了，之前我们是看着两张表之间有关系，但是没有做强制约束，还是两张普通的表，操作其中任何一个，另外一个也没问题，但是加上了这种强制关系之后，他们两个的操作也就都关联起来了，具体操作看下面的代码：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120151602446-643961969.png)

 

　　　　部门表是被关联的表，员工表是关联表，也就是员工表要关联部门表，对吧，如果我们先创建员工表，在创建员工表的时候加外键关系，就会报错，看效果：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120152533625-1565302510.png)

　　　　所以我们应该先建立部门表，也就是被关联的表，因为关联表中的字段的数据是来根据被关联表的被关联字段的数据而来的。

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120152712430-25536712.png)

　　　　然后看一下表结构：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120152905752-1329526259.png)

　　　　表创建好了，如果我们直接给员工表插入几条数据，那么会报错，因为，你的部门还没有呢，你的员工表里面的那个dep_id外键字段的数据从何而来啊？看效果：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120153111250-1169885498.png)

　　　　然后我们先插入部门的数据，然后再插入员工的数据：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120153240961-1689722900.png)

　　　　然后查看一下数据：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120153315045-1186082443.png)

　　　　数据没问题了，但是你有没有发现一个问题，就是员工表的id从6开始的，因为我们前面插入了5条数据，失败了，虽然失败了，但是id自动增长了。

　　　　所以有引出一个问题，如果想让id从头开始，我们可以把这些数据删掉，用delete的删除是没用的，需要用truncate来删除，这是清空表的意思。

　　　　看一下delete：

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120153554703-1406210070.png)

　　　　delete不是用来清空表的，是用来删除一些你想删除的符合某些条件的数据，一般用在delete from tb1 where id>20；这样的，如果要清空表，让id置零，使用truncate

　　　　再看一下truncate：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120154024721-179214293.png)

　　　　然后查看一下数据看看：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120154051601-284934776.png)

　　　　ok，大家练习一下吧~~~~

 　　

　　　　我们来看一下，如果对关联的表进行修改的话会有什么效果，首先我们先修改一下部门表的id字段中的某个数据，将id的值改一下

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120154500902-1514552894.png)

　　　　报错了，那我们改一改员工表里面的外键字段dep_id，改它的值来试试：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120154652114-761405114.png)

　　　　还是报错了！我靠，那我试试删除一下试试，解散一个部门，删除他的数据：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120154736474-1820083889.png)

　　　　报错了！不让你删除，因为你删除之后，员工表里面的之前属于这个部门的记录找不到对应的部门id了，就报错了

　　　　那我删除一下员工表里面关于这个要被解散的部门的员工数据，按理说是不是应该没问题啊，来看看效果：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120155057295-1099231759.png)

　　　　删除成功了，完全没问题啊，那么关于这个部门的所有员工数据都被删除了，也就是说，你这个部门下面没有任何员工了，没有了限制了相当于，所以我们尝试一下看看现在能不能删除部门表里面的这个部门了

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120155259498-1676374078.png)

　　　　ok~可以删除了

　　　　虽然我们修改部门表或者员工表里面的部门id，但是我们可以删除，但是删除这个被关联表部门表的数据的时候由于有关联关系的存在，所以删除的时候也很麻烦，要先将关联数据删除，才能删除被关联的表的数据。

　　　　刚才我们删除了教学部这个部门，当我们想解散这个部门的时候，首先想到的是什么，是不是我们的部门表，想直接操作部门表进行删除，对吧，想修改部门的id号，是不是首先想到的也是操作部门表进行修改，把部门的id修改了，但是我们由于关联关系的存在，不得不考虑关联表中的数据，对不对，所以操作就变得很麻烦了，有没有简单的方法呢？我们想做的是不是说，我想删除一个部门，直接删除部门表里面的数据就行了，是不是达到这个效果，删除一个部门的时候，与这个部门关联的所有的员工表的那些数据都跟着删除，或者我更新部门表中一个部门的id号，那么关联的员工表中的关联字段的部门id号跟着自动更新了，

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120160841065-272740197.png)

　　

　　　　看一下解决办法：

　　　　首先我们把之前的两个表删除了，能先删除部门表吗？如果删了部门表，你的员工表是不是找不到对应关系了，你说会不会报错啊，所以先删除员工表：

　　　　　　1.先删除关联表，再删除被关联表，然后我们重新建立两个表，然后建表的时候说一下咱们的解决方案。

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120161230284-1451777591.png)

 

　　　　　　2.重建表，我们现在要解决的问题是：我们要达到一个在做某个表(被关联表)更新或者删除操作的时候，关联表的数据同步的进行更新和删除的效果，所以我们在建表的时候，可以加上两个功能：同步更新和同步删除：看看如何实现：在建立关联关系的时候，加上这两句： on delete cascade和 on update cascade

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120162027140-391143965.png)

　　　　　　然后把我们之间的表和数据都插入进去：然后再进行更新删除操作：

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120162127654-2145260854.png)

 

　　　　　　然后我们再直接删除部门表里面的数据的时候，你看看结果：

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120162232053-2012516333.png)

　　　　　　成功了，并且员工表里面关联部门表id的数据也都删除了，是不是达到了我们刚才想要实现的效果呀

　　　　　　下面我们来看一下更新操作，我们之前说更新一个部门的id号，注意一个问题昂，我更新部门的名称，你说有影响吗？肯定没有啊，因为我员工表并不是关联的部门的名称字段，而是关联的部门的id字段，你改部门名称没关系，我通过你的id照样找到你，但是你如果改了id号，那么我员工表里面的id号和你不匹配了，我就没法找到你，所有当你直接更新部门的id的时候，我就给你报错了，大哥，你想改的是关联字段啊，考虑一下关联表的数据们的感受行不行。我们来看一下加上 on update cascade之后的效果：

 　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120162743120-1025924790.png)

　　　　　　将部门id为2的部门的id改成了200，完全ok，员工表里面之前关联id为2的部门的数据都改成了关联id为200的数据了。说明同步更新也是没问题的。

 

 　　**我们总结一下foreign key的下面几个约束作用：**

　　　　1、先要建立被关联的表才能建立关联表

　　　　2、在插入数据记录的时候，要先向被关联表中插入数据，才能往关联表里面插入数据

　　　　3、更新或者删除数据的时候，都需要考虑关联表和被关联表的关系

　　　　　　解决方案：

　　　　　　　　a.删除表的时候，先删除关联表，再删除被关联表

　　　　　　　　b.重建表的时候，在加外键关联的时候加上这两句：on delete cascade 和 on update cascade

​	一对多的内容大致就说完了，我们看一下多对多的关系

​	**多对多关系**

 　　　　我们上面大致提了一下多对多的关系，下面我们通过一个例子来细讲一下，这个例子就用-->书和出版社的关系来看吧：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120171740684-1420625094.png)

　　　　上面是一对多没问题，我们再来看看书和作者的关系：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120171943958-248866141.png)

　　　　一本书可以有多个作者，一个作者可不可以写多本书，两者之间是不是站在谁的角度去看都是一个一对多的关系啊，那这就是多对多的关系，那我们创建表的时候，需要将两个表都加一个foreign key的字段，但是你添加字段的时候，你想想，能直接给两个表都这一个foreign key字段吗，两个谁先创建，谁后创建，是不是都不行啊，两个表的创建是不是都依赖着另外一张表啊，所以我们之前的加外键字段的方式对于这种多对多的关系是不是就不好用啦，怎么办，我们需要通过第三张表来缓和一下两者的关系，通过第三张表来创建双方的关系

　　　　我们先创建书表和作者表，然后创建第三张表，第三张表就需要有一个字段外键关联书表，还有一个字段外键关联作者表

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120172905486-41616144.png)

　　　　然后我们如果想查一下alex出了哪些书，你可以怎么查，想一下，首先在author作者表里面找一个alex的id是多少，alex的id为2，然后找一个第三张表里面author_id为2的数据中book的id，然后拿着这些book的id去book表里面找对应的book名称，你就能够知道alex这个作者出了哪几本书了，对不对，这就是一个多表查询的一个思路

　　　　来我们创建一下试试看（学了foreign key，这个东西是不是很简单啊，两个foreign key嘛~~）

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120173957460-1521536555.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120174227313-2029106582.png)

　　　　建立前两张表，插入数据，建立第三张表

　　　　然后给第三张表插入一些数据：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120174348982-440298530.png)

　　　　查看一下数据：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120174408928-1564991357.png)

　　　　数据就创建好了，多对多就讲完了~~~~

　　

　　**一对一关系**

　　　　我们来以咱们学校的学生来举例：

　　　　最开始你只是一个客户，可能还处于咨询考虑的阶段，还没有转化为学生，也有的客户已经转换为学生了，说白了就是你交钱了，哈哈

　　　　那我们来建两个表：客户表和学生表

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120190209104-630390523.png)

　　　　客户表里面存着客户的信息，学生表里面存着客户转换为学生之后的学生信息，那么这两个表是什么关系呢？你想一下，学生是不是从客户转换过来的，那么一个学生能对应多个用户的信息吗？当然是不能的，那么一个客户能对应多个学生的信息吗，当然也是不能的，那么他们两个就是一对一的关系，那这个关系该怎么建立呢？我们知道通过外键可以建立关系，如果在客户表里面加外键关联学生表的话，那说明你的学生表必须先被创建出来，这样肯定是不对的，因为你的客户表先有的，才能转换为学生，那如果在学生表加外键关联客户表的话，貌似是可以的，不过一个学生只对应一个客户，那么这个关系怎么加呢，外键我们知道是一对多的，那怎么搞？我们可以把这个关联字段设置成唯一的，不就可以了吗，我既和你有关联，我还不能重复，那就做到了我和你一对一的关联关系。

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181120191244240-594088333.png)

　　　　

​	一对多简单示例

```mysql
=====================多对一=====================
create table press(
id int primary key auto_increment,
name varchar(20)
);

create table book(
id int primary key auto_increment,
name varchar(20),
press_id int not null,
foreign key(press_id) references press(id)
on delete cascade
on update cascade
);


insert into press(name) values
('北京工业地雷出版社'),
('人民音乐不好听出版社'),
('知识产权没有用出版社')
;

insert into book(name,press_id) values
('九阳神功',1),
('九阴真经',2),
('九阴白骨爪',2),
('独孤九剑',3),
('降龙十巴掌',2),
('葵花宝典',3)
```

​	多对多简单示例

```mysql
=====================多对多=====================
create table author(
id int primary key auto_increment,
name varchar(20)
);


#这张表就存放作者表与书表的关系，即查询二者的关系查这表就可以了
create table author2book(
id int not null unique auto_increment,
author_id int not null,
book_id int not null,
constraint fk_author foreign key(author_id) references author(id)
on delete cascade
on update cascade,
constraint fk_book foreign key(book_id) references book(id)
on delete cascade
on update cascade,
primary key(author_id,book_id)
);


#插入四个作者，id依次排开
insert into author(name) values('egon'),('alex'),('yuanhao'),('wpq');

#每个作者与自己的代表作如下
1 egon: 
      1 九阳神功
      2 九阴真经
      3 九阴白骨爪
      4 独孤九剑
      5 降龙十巴掌
      6 葵花宝典


2 alex: 
      1 九阳神功
      6 葵花宝典

3 yuanhao:
      4 独孤九剑
      5 降龙十巴掌
      6 葵花宝典

4 wpq:
      1 九阳神功


insert into author2book(author_id,book_id) values
(1,1),
(1,2),
(1,3),
(1,4),
(1,5),
(1,6),
(2,1),
(2,6),
(3,4),
(3,5),
(3,6),
(4,1)
;

```

​	一对一简单示例

```mysql
#一定是student来foreign key表customer，这样就保证了：
#1 学生一定是一个客户，
#2 客户不一定是学生，但有可能成为一个学生


create table customer(
id int primary key auto_increment,
name varchar(20) not null,
qq varchar(10) not null,
phone char(16) not null
);


create table student(
id int primary key auto_increment,
class_name varchar(20) not null,
customer_id int unique, #该字段一定要是唯一的
foreign key(customer_id) references customer(id) #外键的字段一定要保证unique
on delete cascade
on update cascade
);


#增加客户
insert into customer(name,qq,phone) values
('李飞机','31811231',13811341220),
('王大炮','123123123',15213146809),
('守榴弹','283818181',1867141331),
('吴坦克','283818181',1851143312),
('赢火箭','888818181',1861243314),
('战地雷','112312312',18811431230)
;


#增加学生
insert into student(class_name,customer_id) values
('脱产3班',3),
('周末19期',4),
('周末19期',5)
;
```

**7.修改表 alter table**

​	下面的内容就不带着大家演示了，简单带大家看一下，都是固定的语法格式，按照这个写就行了，毫无逻辑可言，所以不做太多的演示，大家自己回去练一下：

```
语法：
1. 修改表名
      ALTER TABLE 表名 
                          RENAME 新表名;

2. 增加字段
      ALTER TABLE 表名
                          ADD 字段名  数据类型 [完整性约束条件…], #注意这里可以通过逗号来分割，一下添加多个约束条件
                          ADD 字段名  数据类型 [完整性约束条件…];
      ALTER TABLE 表名
                          ADD 字段名  数据类型 [完整性约束条件…]  FIRST; #添加这个字段的时候，把它放到第一个字段位置去。
      ALTER TABLE 表名
                          ADD 字段名  数据类型 [完整性约束条件…]  AFTER 字段名;#after是放到后的这个字段的后面去了，我们通过一个first和一个after就可以将新添加的字段放到表的任意字段位置了。
                            
3. 删除字段
      ALTER TABLE 表名 
                          DROP 字段名;

4. 修改字段
      ALTER TABLE 表名 
                          MODIFY  字段名 数据类型 [完整性约束条件…];
      ALTER TABLE 表名 
                          CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…];  #change比modify还多了个改名字的功能，这一句是只改了一个字段名
      ALTER TABLE 表名 
                          CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…];#这一句除了改了字段名，还改了数据类型、完整性约束等等的内容
```

​	给一个字段添加外键属性的语句：alter table 表2名 add foreign key(表2的一个字段) references 表1名(表1的一个字段);

​	注意一点：在mysql里面表名是不区分大小写的，如果你将一个名为t1的(小写的t1)改名为一个T1（大写的T1），是完全没用的，因为在数据库里面表名都是小写的。

​	简单示例：

```mysql
示例：
1. 修改存储引擎
mysql> alter table service 
    -> engine=innodb;

2. 添加字段
mysql> alter table student10
    -> add name varchar(20) not null,
    -> add age int(3) not null default 22;
    
mysql> alter table student10
    -> add stu_num varchar(10) not null after name;                //添加name字段之后

mysql> alter table student10                        
    -> add sex enum('male','female') default 'male' first;          //添加到最前面

3. 删除字段
mysql> alter table student10
    -> drop sex;

mysql> alter table service
    -> drop mac;

4. 修改字段类型modify
mysql> alter table student10
    -> modify age int(3);
mysql> alter table student10
    -> modify id int(11) not null primary key auto_increment;    //修改为主键

5. 增加约束（针对已有的主键增加auto_increment）
mysql> alter table student10 modify id int(11) not null primary key auto_increment;
ERROR 1068 (42000): Multiple primary key defined

mysql> alter table student10 modify id int(11) not null auto_increment;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

6. 对已经存在的表增加复合主键
mysql> alter table service2
    -> add primary key(host_ip,port);        

7. 增加主键
mysql> alter table student1
    -> modify name varchar(10) not null primary key;

8. 增加主键和自动增长
mysql> alter table student1
    -> modify id int not null primary key auto_increment;

9. 删除主键
a. 删除自增约束
mysql> alter table student10 modify id int(11) not null; 

b. 删除主键
mysql> alter table student10                                 
    -> drop primary key;

```



## 第三节 MySQL行（记录）的详细操作

#### 本节具体内容如下：   

1. **插入数据INSERT**
2. **更新数据UPDATE**      
3. **删除数据DELETE**
4. **查询数据SELECT**
5. **多表查询**



MySQL数据操作： DML

　　========================================================

　　在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括

1. *使用INSERT实现数据的插入*
2. *UPDATE实现数据的更新*
3. *使用DELETE实现数据的删除*
4. *使用SELECT查询数据以及。*

#### 1.插入数据INSERT

语法

```mysql
1. 插入完整数据（顺序插入）
    语法一：
    INSERT INTO 表名(字段1,字段2,字段3…字段n) VALUES(值1,值2,值3…值n); #指定字段来插入数据，插入的值要和你前面的字段相匹配

    语法二：
    INSERT INTO 表名 VALUES (值1,值2,值3…值n); #不指定字段的话，就按照默认的几个字段来插入数据

2. 指定字段插入数据
    语法：
    INSERT INTO 表名(字段1,字段2,字段3…) VALUES (值1,值2,值3…);

3. 插入多条记录
    语法：#插入多条记录用逗号来分隔
    INSERT INTO 表名 VALUES
        (值1,值2,值3…值n),
        (值1,值2,值3…值n),
        (值1,值2,值3…值n);
        
4. 插入查询结果
    语法：
    INSERT INTO 表名(字段1,字段2,字段3…字段n) 
                    SELECT (字段1,字段2,字段3…字段n) FROM 表2
                    WHERE …; #将从表2里面查询出来的结果来插入到我们的表中，但是注意查询出来的数据要和我们前面指定的字段要对应好
```

#### 2.更新数据UPDATE

```mysql
语法：
    UPDATE 表名 SET 
        字段1=值1,  #注意语法，可以同时来修改多个值，用逗号分隔
        字段2=值2,
        WHERE CONDITION; #更改哪些数据，通过where条件来定位到符合条件的数据

示例：
    UPDATE mysql.user SET password=password(‘123’) 
        where user=’root’ and host=’localhost’; #这句话是对myslq这个库中的user表中的user字段为'root'并且host字段为'localhost'的这条记录的password字段的数据进行修改，将passord字段的那个数据改为password('123')这个方法对123加工后的密码数据，password()这个方法是mysql提供的密码进行加密用的方法。
        定位到某个记录，并把这个记录中的某项内容更改掉
```

#### 3.删除数据DELETE

```mysql
语法：
    DELETE FROM 表名 
        WHERE CONITION; #删除符合条件的一些记录
    DELETE FROM 表名；如果不加where条件，意思是将表里面所有的内容都删掉，但是清空所有的内容，一般我们用truncate ，能够将id置为零，delete不能将id置零，再插入数据的时候，会按照之前的数据记录的id数继续递增
示例：
    DELETE FROM mysql.user 
        WHERE password=’123’;

练习：
    更新MySQL root用户密码为mysql123
    删除除从本地登录的root用户以外的所有用户
```



#### 4.查询数据SELECT

​	我们在工作中，多数的场景都是对数据的增删改操作少，读数据的操作多，所以我们的重点就在读取数据这里了。

　　之前我们说，我们是不是将数据分到多个表中进行保存，而不是将所有的数据都放到一个表里面，例如我们前面所说的部门表和员工表，员工的信息放到一个表里面，部门的信息放到一个部门表里面。

　　虽然我们把数据分到了不同的表里面，但是这些数据是不是属于我们同一个项目的，也就是说，你将来查询数据的时候，可能不单单的从一张表里面来查询数据，可能涉及到一下查询出来多个表中的数据，也就是多表关联查询，对不对，那么我们先来把单表查询学习一下，再来进行多表查询的学习。

单表查询简单语法

```mysql
#查询数据的本质：mysql会到你本地的硬盘上找到对应的文件，然后打开文件，按照你的查询条件来找出你需要的数据。下面是完整的一个单表查询的语法

select * from，这个select * 指的是要查询所有字段的数据。

SELECT distinct 字段1,字段2... FROM 库名.表名 #from后面是说从库的某个表中去找数据，mysql会去找到这个库对应的文件夹下去找到你表名对应的那个数据文件，找不到就直接报错了，找到了就继续后面的操作
                  WHERE 条件       #从表中找符合条件的数据记录，where后面跟的是你的查询条件
                  GROUP BY field（字段）   #分组
                  HAVING 筛选      #过滤，过滤之后执行select后面的字段筛选，就是说我要确定一下需要哪个字段的数据，你查询的字段数据进行去重，然后在进行下面的操作
                  ORDER BY field（字段）   #将结果按照后面的字段进行排序
                  LIMIT 限制条数    #将最后的结果加一个限制条数，就是说我要过滤或者说限制查询出来的数据记录的条数

关于上面这些内容，我们在下面一个一个的来详细解释

```

关键字的执行优先级(重点)

```
   1.找到表:from

　　2.拿着where指定的约束条件，去文件/表中取出一条条记录

　　3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组

　　4.将分组的结果进行having过滤

　　5.执行select

　　6.去重

　　7.将结果按条件排序：order by

　　8.限制结果的显示条数
```



简单查询

```mysql
#我们来创建一个员工表，然后对员工表进行一个简单的查询，来看一下效果，下面是员工表的字段
company.employee
    员工id      id                  int             
    姓名        emp_name            varchar
    性别        sex                 enum
    年龄        age                 int
    入职日期     hire_date           date
    岗位        post                varchar
    职位描述     post_comment        varchar
    薪水        salary              double
    办公室       office              int
    部门编号     depart_id           int



#创建表
create table employee(
    id int not null unique auto_increment,
    name varchar(20) not null,
    sex enum('male','female') not null default 'male', #大部分是男的
    age int(3) unsigned not null default 28,
    hire_date date not null,
    post varchar(50),
    post_comment varchar(100),
    salary double(15,2),
    office int, #一个部门一个屋子
    depart_id int
);


#查看表结构
mysql> desc employee;
+--------------+-----------------------+------+-----+---------+----------------+
| Field        | Type                  | Null | Key | Default | Extra          |
+--------------+-----------------------+------+-----+---------+----------------+
| id           | int(11)               | NO   | PRI | NULL    | auto_increment |
| name         | varchar(20)           | NO   |     | NULL    |                |
| sex          | enum('male','female') | NO   |     | male    |                |
| age          | int(3) unsigned       | NO   |     | 28      |                |
| hire_date    | date                  | NO   |     | NULL    |                |
| post         | varchar(50)           | YES  |     | NULL    |                |
| post_comment | varchar(100)          | YES  |     | NULL    |                |
| salary       | double(15,2)          | YES  |     | NULL    |                |
| office       | int(11)               | YES  |     | NULL    |                |
| depart_id    | int(11)               | YES  |     | NULL    |                |
+--------------+-----------------------+------+-----+---------+----------------+

#插入记录
#三个部门：教学，销售，运营
insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values
('egon','male',18,'20170301','老男孩驻沙河办事处外交大使',7300.33,401,1), #以下是教学部，全都是老师
('alex','male',78,'20150302','teacher',1000000.31,401,1),
('wupeiqi','male',81,'20130305','teacher',8300,401,1),
('yuanhao','male',73,'20140701','teacher',3500,401,1),
('liwenzhou','male',28,'20121101','teacher',2100,401,1),
('jingliyang','female',18,'20110211','teacher',9000,401,1),
('jinxin','male',18,'19000301','teacher',30000,401,1),
('成龙','male',48,'20101111','teacher',10000,401,1),

('歪歪','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门
('丫丫','female',38,'20101101','sale',2000.35,402,2),
('丁丁','female',18,'20110312','sale',1000.37,402,2),
('星星','female',18,'20160513','sale',3000.29,402,2),
('格格','female',28,'20170127','sale',4000.33,402,2),

('张野','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门
('程咬金','male',18,'19970312','operation',20000,403,3),
('程咬银','female',18,'20130311','operation',19000,403,3),
('程咬铜','male',18,'20150411','operation',18000,403,3),
('程咬铁','female',18,'20140512','operation',17000,403,3)
;

#ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbk
```

查询操作示例

```mysql
简单查询
    SELECT id,name,sex,age,hire_date,post,post_comment,salary,office,depart_id 
    FROM employee;

    SELECT * FROM employee; #不推荐用* ，查询的时候*的效率低，至于为什么低，后面会讲到，先知道一下就行了

    SELECT name,salary FROM employee;

#避免重复DISTINCT
   SELECT post FROM employee;#直接这样查询我们会看到很多重复的内容，我只想看一下有哪些职位，那么多重复的内容是没用的，所以我们加一个去重的功能，叫做distinct 
　　SELECT DISTINCT post FROM employee;  #对查询出来的记录进行去重，如果post职位有重复的，就会被剔除，剩下不重复的内容，注意，因为我们查询出来的记录里面只有一个字段post，才会根据post来进行去重
   SELECT DISTINCT post，salary FROM employee；#但是如果这样写，你会发现，貌似没有起到根据post来去重的效果，因为你的去重条件变成了post和salary两个字段的数据，只有他俩合起来是一个重复记录的时候才会去重   
   
　　看一下下面这两句的效果就明白了：注意一点，使用distinct对记录进行去重的时候，distinct必须写在所有查询字段的前面，不然会报错，当然有些特别的用法可以结合着写到字段的中间或者后面，这个后面学到了我们再说
   select post，sex from employee；
   select distinct post，sex from employee；

#通过四则运算查询
    SELECT name, salary*12 FROM employee; #查询每个人的年薪，月薪我们有记录，查年薪呢？简单的乘以12就可以了，from 库.表的时候，我们已经通过use 库名；来指定了库了，所以from的时候直接写from 表，就行了
    #你会发现，结果是出来了，但是我们的那个薪资的字段名变成了salary*12，是因为我们通过查询语句查询出来的也是一张表，但是这个表是不是内存当中的一个虚拟表，并不是我们硬盘中存的那个完整的表，对吧，虚拟表是不是也有标题和记录啊，既然是一个表，我们是可以指定这个虚拟表的标题的，通过as+新字段名来指定

    SELECT name, salary*12 AS Annual_salary FROM employee; #as + 新字段名，就是起一个别名的意思，上面的那个salary*12的字段名也是一个别名，只不过不直观，是mysql自动给你写上的
    SELECT name, salary*12 Annual_salary FROM employee;
　　#除了乘法以外，加减乘除都是可以的


#自定义显示格式，自己规定查询结果的显示格式
   CONCAT() 函数用于连接字符串
   SELECT CONCAT('姓名: ',name,'  年薪: ', salary*12)  AS Annual_salary  #我想让name这个字段显示的字段名称是中文的姓名，让salary*12显示的是中文的年薪，
   FROM employee;#看结果：通过结果你可以看出，这个concat就是帮我们做字符串拼接的，并且拼接之后的结果，都在一个叫做Annual_salary的字段中了
　　　　+---------------------------------------+
　　　　| Annual_salary |
　　　　+---------------------------------------+
　　　　| 姓名: egon 年薪: 87603.96 |
　　　　| 姓名: alex 年薪: 12000003.72 |
　　　　| 姓名: wupeiqi 年薪: 99600.00 |
　　　　| 姓名: yuanhao 年薪: 42000.00 |

　　　　.....

       +---------------------------------------+

   SELECT CONCAT('姓名: ',name,'  年薪: ', salary*12)  AS Annual_salary,CONCAT('性别：',sex) from employee;#还可以这样分成两列　　


   CONCAT_WS() 第一个参数为分隔符来进行字符串拼接
   SELECT CONCAT_WS(':',name,salary*12)  AS Annual_salary  #通过冒号来将name和salary连接起来
   FROM employee;
   #上面这个效果我们也可以通过concat来实现：SELECT CONCAT(name,':',salary*12)  AS Annual_salary from employee;
   结合CASE语句：结合条件来对查询的结果进行一些加工操作
   SELECT
       (
           CASE
           WHEN NAME = 'egon' THEN
               NAME
           WHEN NAME = 'alex' THEN
               CONCAT(name,'_BIGSB')
           ELSE
               concat(NAME, 'SB')
           END
       ) as new_name,sex
   FROM
       employee;

#看结果:
　　　　+--------------+--------+
　　　　| new_name | sex |
　　　　+--------------+--------+
　　　　| egon | male |
　　　　| alex_BIGSB | male |
　　　　| wupeiqiSB | male |
　　　　| yuanhaoSB | male |
　　　　| liwenzhouSB | male |
　　　　| jingliyangSB | female |
　　　　| jinxinSB | male |
　　　　| 成龙SB | male |

　　　　...

　　　　+--------------+
```



WHERE约束

​	where语句中可以使用：

　　　　之前我们用where 后面跟的语句是不是id=1这种类型的啊，用=号连接的，除了=号外，还能使用其他的，看下面：

   1. 比较运算符：> < >= <= <> !=
         2. between 80 and 100 值在80到100之间
              　　3. in(80,90,100)  值是80或90或100
                    　　4. like 'egon%'

                  　　pattern可以是%或_，
                      　　%表示任意多字符
                      　　_表示一个字符 
              　　5. 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not

示例如下：

```mysql
#1:单条件查询
    SELECT name FROM employee
        WHERE post='sale';  #注意优先级，我们说where的优先级是不是比select要高啊，所以我们的顺序是先找到这个employee表，然后按照post='sale'的条件，然后去表里面select数据
        
#2:多条件查询
    SELECT name,salary FROM employee 
        WHERE post='teacher' AND salary>10000;

#3:关键字BETWEEN AND 写的是一个区间
    SELECT name,salary FROM employee 
        WHERE salary BETWEEN 10000 AND 20000; #就是salary>=10000 and salary<=20000的数据

    SELECT name,salary FROM employee 
        WHERE salary NOT BETWEEN 10000 AND 20000; #加个not，就是不在这个区间内，薪资小于10000的或者薪资大于20000的，注意没有等于，
    
#4:关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS) 判断null只能用is
    SELECT name,post_comment FROM employee 
        WHERE post_comment IS NULL;

    SELECT name,post_comment FROM employee 
        WHERE post_comment IS NOT NULL;
        
    SELECT name,post_comment FROM employee 
        WHERE post_comment=''; 注意''是空字符串，不是null，两个是不同的东西，null是啥也没有，''是空的字符串的意思，是一种数据类型，null是另外一种数据类型
    ps：
        执行
        update employee set post_comment='' where id=2;
        再用上条查看，就会有结果了

#5:关键字IN集合查询
    SELECT name,salary FROM employee 
        WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ; #这样写是不是太麻烦了，写一大堆的or，下面我们用in这个简单的写法来搞
    
    SELECT name,salary FROM employee 
        WHERE salary IN (3000,3500,4000,9000) ;

    SELECT name,salary FROM employee 
        WHERE salary NOT IN (3000,3500,4000,9000) ;

#6:关键字LIKE模糊查询，模糊匹配，可以结合通配符来使用
    通配符’%’  #匹配任意所有字符
    SELECT * FROM employee 
            WHERE name LIKE 'eg%';

    通配符’_’  #匹配任意一个字符   
    SELECT * FROM employee 
            WHERE name LIKE 'al__'; #注意我这里写的两个_，用1个的话，匹配不到alex，因为al后面还有两个字符ex。
```

​	where条件咱们就说完了，这个where条件到底怎么运作的，我们来说一下：我们以select id,name,age from employee where id>7;这个语句来说一下

　　首先先找到employee表，找到这个表之后，mysql会拿着where后面的约束条件去表里面找符合条件的数据，然后遍历你表中所有的数据，查看一下id是否大于7，逐条的对比，然后只要发现id比7大的，它就会把这一整条记录给select，但是select说我只拿id、name、age这个三个字段里面的数据，然后就打印了这三个字段的数据，然后where继续往下过滤，看看id是不是还有大于7的，然后发现一个符合条件的就给select一个，然后重复这样的事情，直到把数据全部过滤一遍才会结束。这就是where条件的一个工作方式。

分组查询GROUP BY

​	为什么要分组

```
#1、首先明确一点：分组发生在where之后，即分组是基于where之后得到的记录而进行的

#2、分组指的是：将所有记录按照某个相同字段进行归类，比如针对员工信息表的职位分组，或者按照性别进行分组等

#3、为何要分组呢？是因为我们有时候会需要以组为单位来统计一些数据或者进行一些计算的，对不对，比方说下面的几个例子
    取每个部门的最高工资  
    取每个部门的员工数
    取男人数和女人数  

    小窍门：‘每’这个字后面的字段，就是我们分组的依据，只是个小窍门，但是不能表示所有的情况，看上面第三个分组，没有'每'字，这个就需要我们通过语句来自行判断分组依据了
    我们能用id进行分组吗，能，但是id是不是重复度很低啊，基本没有重复啊，对不对，这样的字段适合做分组的依据吗？不适合，对不对，依据性别分组行不行，当然行，因为性别我们知道，是不是就两种啊，也可能有三种是吧，这个重复度很高，对不对，分组来查的时候才有更好的意义
　　
#4、大前提：
    可以按照任意字段分组，但是分组完毕后，比如group by post，只能查看post字段，如果想查看组内信息，需要借助于聚合函数

#注意一点，在查询语句里面select 字段 from 表，这几项是必须要有的，其他的什么where、group by等等都是可有可无的


单独使用GROUP BY关键字分组
    SELECT post FROM employee GROUP BY post;
    注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数

GROUP BY关键字和GROUP_CONCAT()函数一起使用,比如说我想按部门分组，每个组有哪些员工，都显示出来，怎么搞
    SELECT post,GROUP_CONCAT(name) FROM employee GROUP BY post;#按照岗位分组，并查看组内所有成员名，通过逗号拼接在一起
    SELECT post,GROUP_CONCAT(name,':',salary) as emp_members FROM employee GROUP BY post;

GROUP BY一般都会与聚合函数一起使用，聚合是什么意思：聚合就是将分组的数据聚集到一起，合并起来搞事情，拿到一个最后的结果
    select post,count(id) as count from employee group by post;#按照岗位分组，并查看每个组有多少人，每个人都有唯一的id号，我count是计算一下分组之后每组有多少的id记录，通过这个id记录我就知道每个组有多少人了

关于集合函数，mysql提供了以下几种聚合函数：count、max、min、avg、sum等，上面的group_concat也算是一个聚合函数了，做字符串拼接的操作

```

​	注意：

```
如果我们用设置了unique约束的字段作为分组的依据，则每一条记录自成一组，这种分组没有意义
多条记录之间的某个字段值相同，该字段通常用来作为分组的依据
```



聚合函数

```mysql
#强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组

示例：
    SELECT COUNT(*) FROM employee;  #count是统计个数用的
    SELECT COUNT(*) FROM employee WHERE depart_id=1;  #后面跟where条件的意思是统计一下满足depart_id=1这个的所有记录的个数
    SELECT MAX(salary) FROM employee;  #max（）统计分组后每组的最大值，这里没有写group by，那么就是统计整个表中所有记录中薪资最大的，薪资的值
    SELECT MIN(salary) FROM employee;
    SELECT AVG(salary) FROM employee;
    SELECT SUM(salary) FROM employee;
    SELECT SUM(salary) FROM employee WHERE depart_id=3;
```



HAVING过滤

​	讲having之前，我们补充一个点：之前我们写的查询语句是这样的：select id,name from employee;实际上我们在select每个字段的时候，省略了一个表名，有的人可能会这样写，select employee.id,employee.name from employee;你会发现查询出来的结果是一样的，但是如果你要将查询出来的结果表，起一个新表名的话，带着表名这样写就错了

　　**select employee.id,employee.name from employee as tb1;这样执行会下面的报错：**

　　　　mysql> select employee.id,employee.name from employee as tb1;
　　　　ERROR 1054 (42S22): Unknown column 'employee.id' in 'field list'

 

　    因为这个语句先执行的是谁啊，是不是我们的from啊，那么后面的as也是比select要先执行的，所以你先将表employee起了个新名字叫做tb1，然后在tb1里面取查询数据，那么tb1里面找不到employee.id这个字段，就会报错，如果我们查询的时候不带表名，你as来起一个新的表名也是没问题的，简单提一下这个内容，知道就好了

　　

**HAVING与WHERE不一样的地方在于!!!!!!**

```
having的语法格式和where是一模一样的，只不过having是在分组之后进行的进一步的过滤，where不能使用聚合函数，having是可以使用聚合函数的
#！！！执行优先级从高到低：where > group by > having 
#1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。

#2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,having是可以使用聚合函数
```

having简单测试

```mysql
#来个需求：统计各部门年龄在30岁及以上的员工的平均薪资，并且保留平均工资大于10000的部门
答案：select post,avg(salary) as new_sa from employee where age>=30 group by post having avg(salary) > 10000;
看结果：
　　+---------+---------------+
　　| post | new_sa |
　　+---------+---------------+
　　| teacher | 255450.077500 |
　　+---------+---------------+
　　1 row in set (0.00 sec)

然后我们看这样一句话：select * from employee having avg(salary) > 10000;
只要一运行就会报错：
　　　　mysql> select * from employee having avg(salary) > 10000;
　　　　ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),...) with no GROUP columns is illegal if there is no GROUP BY clause

是因为having只能在group by后面运行

```



DISTINCT去重

```mysql
有时需要查询出某个字段不重复的记录，这时可以使用mysql提供的distinct这个关键字来过滤重复的记录，但是实际中我们往往用distinct来返回不重复字段的条数（count(distinct id)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段，distinct 想写在其他字段后面需要配合聚合函数来写。

mysql> select id,count(distinct post) from employee;
ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),...) with no GROUP columns is illegal if there is no GROUP BY clause
报错了：是因为distinct不能返回其他的字段，只能返回目标字段
mysql> select count(distinct post) from employee;
+----------------------+
| count(distinct post) |
+----------------------+
|                    4 |
+----------------------+
1 row in set (0.00 sec)
```



查询排序ORDER BY

```mysql
按单列排序
    SELECT * FROM employee ORDER BY salary; #默认是升序排列
    SELECT * FROM employee ORDER BY salary ASC; #升序
    SELECT * FROM employee ORDER BY salary DESC; #降序

但是你看，如果我们按照age来排序，你看看是什么效果：
mysql> SELECT * FROM employee ORDER BY age;
+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+
| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |
+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+
| 1 | egon | male | 18 | 2017-03-01 | 老男孩驻沙河办事处外交大使 | NULL | 7300.33 | 401 | 1 |
| 17 | 程咬铜 | male | 18 | 2015-04-11 | operation | NULL | 18000.00 | 403 | 3 |
| 16 | 程咬银 | female | 18 | 2013-03-11 | operation | NULL | 19000.00 | 403 | 3 |
| 15 | 程咬金 | male | 18 | 1997-03-12 | operation | NULL | 20000.00 | 403 | 3 |
| 12 | 星星 | female | 18 | 2016-05-13 | sale | NULL | 3000.29 | 402 | 2 |
| 11 | 丁丁 | female | 18 | 2011-03-12 | sale | NULL | 1000.37 | 402 | 2 |
| 18 | 程咬铁 | female | 18 | 2014-05-12 | operation | NULL | 17000.00 | 403 | 3 |
| 7 | jinxin | male | 18 | 1900-03-01 | teacher | NULL | 30000.00 | 401 | 1 |
| 6 | jingliyang | female | 18 | 2011-02-11 | teacher | NULL | 9000.00 | 401 | 1 |
| 13 | 格格 | female | 28 | 2017-01-27 | sale | NULL | 4000.33 | 402 | 2 |
| 14 | 张野 | male | 28 | 2016-03-11 | operation | NULL | 10000.13 | 403 | 3 |
| 5 | liwenzhou | male | 28 | 2012-11-01 | teacher | NULL | 2100.00 | 401 | 1 |
| 10 | 丫丫 | female | 38 | 2010-11-01 | sale | NULL | 2000.35 | 402 | 2 |
| 9 | 歪歪 | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 |
| 8 | 成龙 | male | 48 | 2010-11-11 | teacher | NULL | 10000.00 | 401 | 1 |
| 4 | yuanhao | male | 73 | 2014-07-01 | teacher | NULL | 3500.00 | 401 | 1 |
| 2 | alex | male | 78 | 2015-03-02 | teacher | NULL | 1000000.31 | 401 | 1 |
| 3 | wupeiqi | male | 81 | 2013-03-05 | teacher | NULL | 8300.00 | 401 | 1 |
+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+

  发现什么，按照年龄来升序排的，没问题，但是你看年龄相同的那些按什么排的，是不是看着是乱的啊，但是不管它对这种相同数据的内容怎么排序，我们是不是想如果出现相同的数据，那么这些相同的数据也按照一个依据来排列啊：

  所以我们可以给相同的这些数据指定一个排序的依据，看下面：
按多列排序:先按照age升序，如果年纪相同，则按照薪资降序
    SELECT * from employee
        ORDER BY age, #注意排序的条件用逗号分隔
        salary DESC;
```



LIMIT显示查询的记录数

```mysql
示例：
　　#取出工资最高的前三位
    SELECT * FROM employee ORDER BY salary DESC 
        LIMIT 3;                    #默认初始位置为0,从第一条开始顺序取出三条 
    
    SELECT * FROM employee ORDER BY salary DESC
        LIMIT 0,5; #从第0开始，即先查询出第一条，然后包含这一条在内往后查5条 

    SELECT * FROM employee ORDER BY salary DESC
        LIMIT 5,5; #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条

```



正则表达式查询

```mysql
#之前我们用like做模糊匹配，只有%和_，局限性比较强，所以我们说一个正则，之前我们是不是学过正则匹配，你之前学的正则表达式都可以用，正则是通用的
SELECT * FROM employee WHERE name REGEXP '^ale';

SELECT * FROM employee WHERE name REGEXP 'on$';

SELECT * FROM employee WHERE name REGEXP 'm{2}';


小结：对字符串匹配的方式
WHERE name = 'egon';
WHERE name LIKE 'yua%';
WHERE name REGEXP 'on$';
```



#### 5.多表查询

介绍

​	首先说一下，我们写项目一般都会建一个数据库，那数据库里面是不是存了好多张表啊，不可能把所有的数据都放到一张表里面，肯定要分表来存数据，这样节省空间，数据的组织结构更清晰，解耦和程度更高，但是这些表本质上是不是还是一个整体啊，是一个项目所有的数据，那既然分表存了，就要涉及到多个表连接查询了，比如说员工信息一张表，部门信息一张表，那如果我想让你帮我查一下技术部门有哪些员工的姓名，你怎么办，单独找员工表能实现吗，不能，单独找部门表也无法实现，因为部门表里面没有员工的信息，对不对，所以就涉及到部门表和员工表来关联到一起进行查询了，好，那我们来建立这么两张表：

```mysql
#建表
#部门表
create table department(
id int,
name varchar(20) 
);

#员工表，之前我们学过foreign key，强行加上约束关联，但是我下面这个表并没有直接加foreign key，这两个表我只是让它们在逻辑意义上有关系，并没有加foreign key来强制两表建立关系，为什么要这样搞，是有些效果要给大家演示一下
#所以，这两个表是不是先建立哪个表都行啊，如果有foreign key的话，是不是就需要注意表建立的顺序了。那我们来建表。
create table employee(
id int primary key auto_increment,
name varchar(20),
sex enum('male','female') not null default 'male',
age int,
dep_id int
);

#给两个表插入一些数据
insert into department values
(200,'技术'),
(201,'人力资源'),
(202,'销售'),
(203,'运营'); #注意这一条数据，在下面的员工表里面没有对应这个部门的数据

insert into employee(name,sex,age,dep_id) values
('egon','male',18,200),
('alex','female',48,201),
('wupeiqi','male',38,201),
('yuanhao','female',28,202),
('liwenzhou','male',18,200),
('jingliyang','female',18,204) #注意这条数据的dep_id字段的值，这个204，在上面的部门表里面也没有对应的部门id。所以两者都含有一条双方没有涉及到的数据，这都是为了演示一下效果设计的昂
;


#查看表结构和数据
mysql> desc department;
+-------+-------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(20) | YES | | NULL | |
+-------+-------------+------+-----+---------+-------+

mysql> desc employee;
+--------+-----------------------+------+-----+---------+----------------+
| Field | Type | Null | Key | Default | Extra |
+--------+-----------------------+------+-----+---------+----------------+
| id | int(11) | NO | PRI | NULL | auto_increment |
| name | varchar(20) | YES | | NULL | |
| sex | enum('male','female') | NO | | male | |
| age | int(11) | YES | | NULL | |
| dep_id | int(11) | YES | | NULL | |
+--------+-----------------------+------+-----+---------+----------------+

mysql> select * from department;
+------+--------------+
| id | name |
+------+--------------+
| 200 | 技术 |
| 201 | 人力资源 |
| 202 | 销售 |
| 203 | 运营 |
+------+--------------+

mysql> select * from employee;
+----+------------+--------+------+--------+
| id | name | sex | age | dep_id |
+----+------------+--------+------+--------+
| 1 | egon | male | 18 | 200 |
| 2 | alex | female | 48 | 201 |
| 3 | wupeiqi | male | 38 | 201 |
| 4 | yuanhao | female | 28 | 202 |
| 5 | liwenzhou | male | 18 | 200 |
| 6 | jingliyang | female | 18 | 204 |
+----+------------+--------+------+--------+
```

多表连接查询

```mysql
#重点：外链接语法

SELECT 字段列表
    FROM 表1 INNER|LEFT|RIGHT JOIN 表2
    ON 表1.字段 = 表2.字段;
```

交叉连接：不适用任何匹配条件。生成笛卡尔积

​	补充一点：select 查询表的时候，后面可以跟多张表一起查询：

```mysql
mysql> select * from department,employee; #表用逗号分隔，看我查询时表的顺序，先department后employee，所以你看结果表的这些字段，是不是就是我们两个表字段并且哪个表在前面，哪个表的字段就在前面
+------+--------------+----+------------+--------+------+--------+
| id   | name         | id | name       | sex    | age  | dep_id |
+------+--------------+----+------------+--------+------+--------+
|  200 | 技术         |  1 | egon       | male   |   18 |    200 |
|  201 | 人力资源     |  1 | egon       | male   |   18 |    200 |
|  202 | 销售         |  1 | egon       | male   |   18 |    200 |
|  203 | 运营         |  1 | egon       | male   |   18 |    200 |
|  200 | 技术         |  2 | alex       | female |   48 |    201 |
|  201 | 人力资源     |  2 | alex       | female |   48 |    201 |
|  202 | 销售         |  2 | alex       | female |   48 |    201 |
|  203 | 运营         |  2 | alex       | female |   48 |    201 |
|  200 | 技术         |  3 | wupeiqi    | male   |   38 |    201 |
|  201 | 人力资源     |  3 | wupeiqi    | male   |   38 |    201 |
|  202 | 销售         |  3 | wupeiqi    | male   |   38 |    201 |
|  203 | 运营         |  3 | wupeiqi    | male   |   38 |    201 |
|  200 | 技术         |  4 | yuanhao    | female |   28 |    202 |
|  201 | 人力资源     |  4 | yuanhao    | female |   28 |    202 |
|  202 | 销售         |  4 | yuanhao    | female |   28 |    202 |
|  203 | 运营         |  4 | yuanhao    | female |   28 |    202 |
|  200 | 技术         |  5 | liwenzhou  | male   |   18 |    200 |
|  201 | 人力资源     |  5 | liwenzhou  | male   |   18 |    200 |
|  202 | 销售         |  5 | liwenzhou  | male   |   18 |    200 |
|  203 | 运营         |  5 | liwenzhou  | male   |   18 |    200 |
|  200 | 技术         |  6 | jingliyang | female |   18 |    204 |
|  201 | 人力资源     |  6 | jingliyang | female |   18 |    204 |
|  202 | 销售         |  6 | jingliyang | female |   18 |    204 |
|  203 | 运营         |  6 | jingliyang | female |   18 |    204 |
+------+--------------+----+------------+--------+------+--------+
24 rows in set (0.12 sec)

我们让employee表在前面看看结果，注意看结果表的字段
mysql> select * from employee,department;
+----+------------+--------+------+--------+------+--------------+
| id | name | sex | age | dep_id | id | name |
+----+------------+--------+------+--------+------+--------------+
| 1 | egon | male | 18 | 200 | 200 | 技术 |
| 1 | egon | male | 18 | 200 | 201 | 人力资源 |
| 1 | egon | male | 18 | 200 | 202 | 销售 |
| 1 | egon | male | 18 | 200 | 203 | 运营 |
| 2 | alex | female | 48 | 201 | 200 | 技术 |
| 2 | alex | female | 48 | 201 | 201 | 人力资源 |
| 2 | alex | female | 48 | 201 | 202 | 销售 |
| 2 | alex | female | 48 | 201 | 203 | 运营 |
| 3 | wupeiqi | male | 38 | 201 | 200 | 技术 |
| 3 | wupeiqi | male | 38 | 201 | 201 | 人力资源 |
| 3 | wupeiqi | male | 38 | 201 | 202 | 销售 |
| 3 | wupeiqi | male | 38 | 201 | 203 | 运营 |
| 4 | yuanhao | female | 28 | 202 | 200 | 技术 |
| 4 | yuanhao | female | 28 | 202 | 201 | 人力资源 |
| 4 | yuanhao | female | 28 | 202 | 202 | 销售 |
| 4 | yuanhao | female | 28 | 202 | 203 | 运营 |
| 5 | liwenzhou | male | 18 | 200 | 200 | 技术 |
| 5 | liwenzhou | male | 18 | 200 | 201 | 人力资源 |
| 5 | liwenzhou | male | 18 | 200 | 202 | 销售 |
| 5 | liwenzhou | male | 18 | 200 | 203 | 运营 |
| 6 | jingliyang | female | 18 | 204 | 200 | 技术 |
| 6 | jingliyang | female | 18 | 204 | 201 | 人力资源 |
| 6 | jingliyang | female | 18 | 204 | 202 | 销售 |
| 6 | jingliyang | female | 18 | 204 | 203 | 运营 |
+----+------------+--------+------+--------+------+--------------+
24 rows in set (0.00 sec)


关于笛卡儿积：我们看一下上面的这些数据，有什么发现，首先看到这些字段都显示出来了，并且数据变得很多，我们来看一下，这么多条数据都是怎么来的，为什么会出现这么条数据，笛卡儿积这是一个数据名词，你可以去研究研究~~

　　因为我们要进行连表查询，那么mysql并不知道你想要如何连接两个表的关系进行查询，那么mysql会将你两个表数据的所有组合关系都给你拼接成一条数据来显示，这样你就可以想查哪个关联关系的数据就查哪个了，如果还是不太理解看一下下面的图：
```

​	关于笛卡儿积现象的解释图：

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181123165130845-264296897.png)

​		咱们为了更好的管理数据，为了节省空间，为了数据组织结构更清晰，将数据拆分到了不同表里面，但是本质上是不是还是一份数据，一份重复内容很多的很大的数据，所以我们即便是分表了，但是咱们是不是还需要找到一个方案把两个本来分开的表能够合并到一起来进行查询，那你是不是就可以根据部门找员工，根据员工找部门了，对不对，但是我们合并两个表的时候，如何合并，根据什么来合并，通过笛卡儿积这种合并有没有浪费，我们其实想做的是不是说我们的员工表中dep_id这个字段中的数据和部门表里面的id能够对应上就可以了，因为我们知道我们设计表的时候，是通过这两个字段来给两个表建立关系的，对不对，看下图：

　　　　**![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181123170733686-1528734466.png)**

　　　　我们的目标就是将两个分散出去的表，按照两者之间有关系的字段，能对应上的字段，把两者合并成一张表，这就是多表查询的一个本质。那么笛卡儿积干了什么事儿，就是简单粗暴的将两个表的数据全部对应了一遍，用处就是什么呢，它肯定就能保证有一条是对应准的，你需要做的事情就是在笛卡儿积的基础上只过滤出我们需要的那些数据就行了，笛卡儿积不是咱们最终要得到的结果，只是给你提供了一个基础，它不管对应的对不对，全部给你对应一遍，然后你自己去筛选就可以了，然后基于笛卡儿积我们来找一下对应的数据，看看能不能找到：

内连接：只连接匹配的行

```mysql
#我们要找的数据就是员工表里面dep_id字段的值和部门表里面id字段的值能对应上的那些数据啊，所以你看下面的写法：
mysql> select * from employee,department where employee.dep_id=department.id;
+----+-----------+--------+------+--------+------+--------------+
| id | name      | sex    | age  | dep_id | id   | name         |
+----+-----------+--------+------+--------+------+--------------+
|  1 | egon      | male   |   18 |    200 |  200 | 技术         |
|  2 | alex      | female |   48 |    201 |  201 | 人力资源     |
|  3 | wupeiqi   | male   |   38 |    201 |  201 | 人力资源     |
|  4 | yuanhao   | female |   28 |    202 |  202 | 销售         |
|  5 | liwenzhou | male   |   18 |    200 |  200 | 技术         |
+----+-----------+--------+------+--------+------+--------------+
5 rows in set (0.14 sec)
拿到了我们想要的结果。

但是你看，我们左表employee表中的dep_id为204的那个数据没有了，右表department表的id为203的数据没有了，因为我们现在要的就是两表能对应上的数据一起查出来，那个204和203双方对应不上。

#再看一个需求，我要查出技术部的员工的名字
mysql> select name from employee,department where employee.dep_id=department.id and department.name='技术';
ERROR 1052 (23000): Column 'name' in field list is ambiguous
#上面直接就报错了，因为select后面直接写的name，在两个表合并起来的表中，是有两个name字段的，直接写name是不行的，要加上表名，再看：
mysql> select employee.name from employee,department where employee.dep_id=department.id and department.name='技术';
+-----------+
| name      |
+-----------+
| egon      |
| liwenzhou |
+-----------+
2 rows in set (0.09 sec)
结果就没问题了
```



​	但是你看上面的代码有没有什么不太好的地方，虽然我们能够完成我们的事情，但是代码可读性不好，所以以后不要这么写，但是看图：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181123180131254-1636098034.png)

​	所以mysql为我们提供了一些专门做连表操作的方法，这些方法语义更加的明确，你一看就知道那些代码是连表的，那些代码是查询的，其实上面的连表也是个查询操作，但是我们为了区分明确，连表专门用连表的方法，查询就专门用查询的方法。那这些专门的方法都是什么呢，看后面的内容：



外链接之左连接：优先显示左表全部记录

```mysql
#以左表为准，即找出所有员工信息，当然包括没有部门的员工
#本质就是：在内连接的基础上增加左边有右边没有的结果  #注意语法：
mysql> select employee.id,employee.name,department.name as depart_name from employee left join department on employee.dep_id=department.id;
+----+------------+--------------+
| id | name       | depart_name  |
+----+------------+--------------+
|  1 | egon       | 技术         |
|  5 | liwenzhou  | 技术         |
|  2 | alex       | 人力资源     |
|  3 | wupeiqi    | 人力资源     |
|  4 | yuanhao    | 销售         |
|  6 | jingliyang | NULL         |
+----+------------+--------------+
```

外链接之右连接：优先显示右表全部记录

```mysql
#以右表为准，即找出所有部门信息，包括没有员工的部门
#本质就是：在内连接的基础上增加右边有左边没有的结果
mysql> select employee.id,employee.name,department.name as depart_name from employee right join department on employee.dep_id=department.id;
+------+-----------+--------------+
| id   | name      | depart_name  |
+------+-----------+--------------+
|    1 | egon      | 技术         |
|    2 | alex      | 人力资源     |
|    3 | wupeiqi   | 人力资源     |
|    4 | yuanhao   | 销售         |
|    5 | liwenzhou | 技术         |
| NULL | NULL      | 运营         |
+------+-----------+--------------+
```

全外连接：显示左右两个表全部记录

```mysql
全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果
#注意：mysql不支持全外连接 full JOIN
#强调：mysql可以使用此种方式间接实现全外连接
select * from employee left join department on employee.dep_id = department.id
union
select * from employee right join department on employee.dep_id = department.id
;
#查看结果
+------+------------+--------+------+--------+------+--------------+
| id   | name       | sex    | age  | dep_id | id   | name         |
+------+------------+--------+------+--------+------+--------------+
|    1 | egon       | male   |   18 |    200 |  200 | 技术         |
|    5 | liwenzhou  | male   |   18 |    200 |  200 | 技术         |
|    2 | alex       | female |   48 |    201 |  201 | 人力资源     |
|    3 | wupeiqi    | male   |   38 |    201 |  201 | 人力资源     |
|    4 | yuanhao    | female |   28 |    202 |  202 | 销售         |
|    6 | jingliyang | female |   18 |    204 | NULL | NULL         |
| NULL | NULL       | NULL   | NULL |   NULL |  203 | 运营         |
+------+------------+--------+------+--------+------+--------------+

#注意 union与union all的区别：union会去掉相同的纪录，因为union all是left join 和right join合并，所以有重复的记录，通过union就将重复的记录去重了。
```



子查询

​	子查询其实就是将你的一个查询结果用括号括起来，这个结果也是一张表，就可以将它交给另外一个sql语句，作为它的一个查询依据来进行操作。

　　来，我们简单来个需求：技术部都有哪些员工的姓名，都显示出来：　1、看一下和哪个表有关，然后from找到两个表  2、进行一个连表操作　3、基于连表的结果来一个过滤就可以了

```mysql
#我们之前的做法是：先连表
mysql> select * from employee inner join department on employee.dep_id = department.id; 
+----+-----------+--------+------+--------+------+--------------+
| id | name      | sex    | age  | dep_id | id   | name         |
+----+-----------+--------+------+--------+------+--------------+
|  1 | egon      | male   |   18 |    200 |  200 | 技术         |
|  2 | alex      | female |   48 |    201 |  201 | 人力资源     |
|  3 | wupeiqi   | male   |   38 |    201 |  201 | 人力资源     |
|  4 | yuanhao   | female |   28 |    202 |  202 | 销售         |
|  5 | liwenzhou | male   |   18 |    200 |  200 | 技术         |
+----+-----------+--------+------+--------+------+--------------+
5 rows in set (0.10 sec)

#然后根据连表的结果进行where过滤，将select*改为select employee.name

mysql> select employee.name from employee inner join department on employee.dep_id = department.id where department.name='技术';
  +-----------+
  | name |
  +-----------+
  | egon |
  | liwenzhou |
  +-----------+
  2 rows in set (0.09 sec)
```

​	然后看一下子查询这种方式的写法：它的做法就是解决完一个问题，再解决下一个问题，针对我们上面的需求，你想，我们的需求是不是说找技术部门下面有哪些员工对不对，如果你直接找员工表，你能确定哪个dep_id的数值表示的是技术部门吗，不能，所以咱们是不是应该先确定一个技术部门对应的id号是多少，然后根据部门的id号，再去员工表里面查询一下dep_id为技术部门对应的部门表的那个id号的所有的员工表里面的记录：好，那我们看一下下面的操作

```mysql
#首先从部门表里面找到技术部门对应的id
mysql> select id from department where name='技术';
+------+
| id   |
+------+
|  200 |
+------+
1 row in set (0.00 sec)

#那我们把上面的查询结果用括号括起来，它就表示一条id=200的数据，然后我们通过员工表来查询dep_id=这条数据作为条件来查询员工的name
mysql> select name from employee where dep_id = (select id from department where name='技术');
+-----------+
| name      |
+-----------+
| egon      |
| liwenzhou |
+-----------+
2 rows in set (0.00 sec)
上面这些就是子查询的一个思路，解决一个问题，再解决另外一个问题，你子查询里面可不可以是多个表的查询结果，当然可以，然后再通过这个结果作为依据来进行过滤，然后我们学一下子查询里面其他的内容，往下学。
```

```mysql
子查询：
#1：子查询是将一个查询语句嵌套在另一个查询语句中。
#2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。
#3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字
#4：还可以包含比较运算符：= 、 !=、> 、<等
```

​	**带IN关键字的子查询示例**

```mysql
#查询员工平均年龄在25岁以上的部门名，可以用连表，也可以用子查询，我们用子查询来搞一下
select id,name from department
    where id in 
        (select dep_id from employee group by dep_id having avg(age) > 25);
#连表来搞一下上面这个需求
select department.name from department inner join employee on department.id=employee.dep_id 
    group by department.name 
    having avg(age)>25;
总结：子查询的思路和解决问题一样，先解决一个然后拿着这个的结果再去解决另外一个问题，连表的思路是先将两个表关联在一起，然后在进行group by啊过滤啊等等操作，两者的思路是不一样的

#查看技术部员工姓名
select name from employee
    where dep_id in 
        (select id from department where name='技术');

#查看不足1人的部门名(子查询得到的是有人的部门id)
select name from department where id not in (select distinct dep_id from employee);
```

​	**带比较运算符的子查询示例**

```mysql
#比较运算符：=、!=、>、>=、<、<=、<>
#查询大于所有人平均年龄的员工名与年龄
mysql> select name,age from emp where age > (select avg(age) from emp);
+---------+------+
| name | age |
+---------+------+
| alex | 48 |
| wupeiqi | 38 |
+---------+------+
2 rows in set (0.00 sec)


#查询大于部门内平均年龄的员工名、年龄
select t1.name,t1.age from emp t1
inner join 
(select dep_id,avg(age) avg_age from emp group by dep_id) t2
on t1.dep_id = t2.dep_id
where t1.age > t2.avg_age; 
```

​	**带EXISTS关键字的子查询示例**

​		EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。而是返回一个真假值。True或False
　　　　当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询。还可以写not exists，和exists的效果就是反的

```mysql
#department表中存在dept_id=203，Ture
mysql> select * from employee
    ->     where exists  
    ->         (select id from department where id=200); 
+----+------------+--------+------+--------+
| id | name       | sex    | age  | dep_id |
+----+------------+--------+------+--------+
|  1 | egon       | male   |   18 |    200 |
|  2 | alex       | female |   48 |    201 |
|  3 | wupeiqi    | male   |   38 |    201 |
|  4 | yuanhao    | female |   28 |    202 |
|  5 | liwenzhou  | male   |   18 |    200 |
|  6 | jingliyang | female |   18 |    204 |
+----+------------+--------+------+--------+

#department表中存在dept_id=205，False
mysql> select * from employee
    ->     where exists
    ->         (select id from department where id=204);
Empty set (0.00 sec)
```



## 第四节 Navicat工具的安装和使用

#### 本节具体内容如下：   

 1. **Navicat安装和使用**

    

#### 1.Navicat安装和使用　　

​	下载地址：<https://pan.baidu.com/s/1bpo5mqj>

　　下载完之后，直接解压出来就能用，看一下解压之后的目录：

　　双击打开下面这个文件（可以把它添加一个桌面快捷方式，或者添加到任务栏）：

　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126154658733-2023821512.png)

　　　　　　然后会提示你输入注册码：

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126154900074-1293565836.png)

　　　　回到navicat的解压出来的文件夹里面，有个叫做key.txt的文件，打开，里面有注册码

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155054393-1028419848.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155118111-626513039.png)

　　　　将这个注册码copy到输入注册码的地方：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155159351-141700574.png)

　　　　点击确定就能打开使用了：会显示出来下面的界面

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155231513-2130046684.png)

　　　　

　　　　既然是mysql客户端，我们需要连接mysql服务端

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155337750-573723451.png)

　　　　在弹出的界面输入mysql服务端的ip地址和端口，还有mysql用户名和密码

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155655941-2090507481.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155733199-1295841191.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155920991-1959058456.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126155952360-1928134149.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126160115711-1566041195.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126160240338-1548786764.png)

　　　　

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126160349947-362477094.png)

 　　　　

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126161859732-107922916.png)

　　　　关于校对规则大家看看这两篇博客就明白了：

　　　　　　<https://www.cnblogs.com/adforce/p/3282404.html>

　　　　　　<https://www.jb51.net/article/48775.htm>

 

 　　　　上面的步骤点击确定就建好一个数据库了：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126161942669-1947467594.png)

　　　　然后我们到上面的数据库里面新建一张表

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126162043727-365899757.png)

 

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126164246084-982641171.png)

　　　　

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126164333294-559090833.png)

　　　　也就是我们自己用鼠标点啊点之类的，也就是生成对应的sql语句去执行

　　　　然后点击保存：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126164507104-314255139.png)

　　　　这个表就生成了：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126164531763-761034549.png)

　　　　不信我们去命令行看一看：这个表就存在了

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126164617256-1445669182.png)

　　　　以后我们直接就使用这个工具来操作数据库就可以了，因为命令行操作还是比较恶心的

　　　　然后我们看看建立外键

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126165045731-1309029963.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126165435031-192334483.png)

　　　　然后自动会生成对应的sql语句

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126165557289-1396994657.png)

　　　　

 　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126165726137-667110156.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126165839172-611925586.png)

　　　　然后点击保存，起一个表名，就有了这个表了

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126170037333-5186620.png)

　　　　然后双击上面的表名就可以插入数据了

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126170106251-1934220404.png)

　　　　

　　　　比方说我们上面这个dep表的id字段没有设置自增，我想改一下，让它这个id字段变为自增的怎么办

　　　　设计表：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126170153376-573026846.png)

　　　　

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126170611581-926623132.png)

　　　　那我们该怎么办呢，直接删除这个表然后重新创建吗？你另外一个关联表肯定不让你这么做，所以你需要先将那个关联表的外键关系先取消，或者先将那个外键关联表删除

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126170750875-395725309.png)

　　　　然后把这个关联表的外键删除，然后保存

　　　　然后再去我们想给id字段加上自增的那个dep表里面把id字段设置为自增，保存，然后在重新将emp表外键到dep的id字段上

　　　　然后给dep表插入几条数据

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126174635025-105251137.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126174922982-1052648321.png)

　　　　这个工具还能将你的表之间的关系通过图形的形式来给你展示：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126175439828-353883028.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126175505054-723447739.png)

　　　　点击这个ER图，两者的关系图就显示出来了，那么将来你的表很多的时候，你就可以通过这个图来查看自己表和表之间的关系，看效果：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126175559728-2095785442.png)

　　　　如果我们点击两个表之间的线，是可以看到两者之间的关系的：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126183452242-1092477632.png)

 

　　　　

 　　　　还可以选择上面的模型来直接创作图表，创建表之间的关系

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126180005552-1157726738.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126180105042-802274929.png)

　　　　但是上面我们建立的这个模型，是不能直接创建到数据库里面的，需要将它以sql的形式导入，然后把导出的sql语句，到数据库里面去执行

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126180238587-1520490896.png)

　　　　然后导出保存到一个地方

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126180331920-1283237974.png)

　　　　打开我们导出的文件，看一下里面的内容

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126181624001-452920219.png)

　　　　你看，就是咱们创建的模型翻译成的sql语句，复制一下这些sql语句，但mysql里面去执行一下，就等到我们模型里面的两个表了，是不是很方便

　　　　Navicat工具还能写原生sql语句来进行数据库的操作

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126181925703-1789280099.png)

　　　　就看到一个输入sql语句的界面了：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126182000115-350919164.png)

　　　　然后写一个sql语句试一下：

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126182110479-612573496.png)

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126182130080-1174810820.png)

　　　　　　然后运行一下：

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126182239211-1531732836.png)

 　　　　　　　

　　　　　　我们还可以将之前数据库中导出来的数据，以sql文件的形式通过navicat导入到数据库中：看步骤

　　　　　　假如我们有一个从数据库中导入的文件，文件名称为init.sql，里面的内容就下面的东东

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) 数据库导出的文件

 

　　　　　　首先我们新建一个库：

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126193828459-409844709.png)

　　　　　　然后选择这个数据库，点击右键，选择运行sql文件；

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126193921581-783141879.png)

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126194024970-835722149.png)

　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126194058762-829324248.png)

　　　　　　注意上面这一步，直接关闭就可以了，不要再次点击开始了

 　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181126194148030-205196086.png)

　　　　　　然后通过ER图，来看看，各个表的关系就看的很清楚了。

　　　　　　

　　　　　　我们还可以对sql语句进行注释：选中语句然后ctrl+/就能多行注释，ctrl+shift+/ 就能取消注释

　　　　　　ok，Navicat简单的就介绍完了，大家可以练一练了~~~



## 第五节 pymysql模块

#### 本节具体内容如下：   

1. **简单示例**

2. **execute()之sql注入**

3. **增、删、改：conn.commit()**

4. **查：fetchone，fetchmany，fetchall**

5. **获取插入的最后一条数据的自增ID**

   

我们要学的pymysql就是用来在python程序中如何操作mysql，它和mysql自带的那个客户端还有navicat是一样的，本质上就是一个套接字客户端，只不过这个套接字客户端是在python程序中用的，既然是客户端套接字，应该怎么用，是不是要连接服务端，并且和服务端进行通信啊，让我们来学习一下pymysql这个模块。

```python
#安装
pip3 install pymysql
```

#### 1.简单示例

```python
import pymysql
user=input('用户名: ').strip()
pwd=input('密码: ').strip()

#链接，指定ip地址和端口，本机上测试时ip地址可以写localhost或者自己的ip地址或者127.0.0.1，然后你操作数据库的时候的用户名，密码，要指定你操作的是哪个数据库，指定库名，还要指定字符集。不然会出现乱码
conn=pymysql.connect(host='localhost',port=3306,user='root',password='123',database='student',charset='utf8') #指定编码为utf8的时候，注意没有-，别写utf-8，数据库为
#得到conn这个连接对象
#游标
cursor=conn.cursor() #这就想到于mysql自带的那个客户端的游标mysql> 在这后面输入指令，回车执行
#cursor=conn.cursor(cursor=pymysql.cursors.DictCursor) #获取字典数据类型表示的结果：{'sid': 1, 'gender': '男', 'class_id': 1, 'sname': '理解'} {'字段名':值}


#然后给游标输入sql语句并执行sql语句execute
sql='select * from userinfo where name="%s" and password="%s"' %(user,pwd) #注意%s需要加引号，执行这句sql的前提是医药有个userinfo表，里面有name和password两个字段，还有一些数据，自己添加数据昂
print(sql)
res=cursor.execute(sql) #执行sql语句，返回sql查询成功的记录数目，是个数字，是受sql语句影响到的记录行数，其实除了受影响的记录的条数之外，这些记录的数据也都返回了给游标,这个就相当于我们subprocess模块里面的管道PIPE，乘放着返回的数据
#all_data=cursor.fetchall()  #获取返回的所有数据，注意凡是取数据，取过的数据就没有了，结果都是元祖格式的
#many_data=cursor.fetchmany(3) #一下取出3条数据，
#one_data=cursor.fetchone()  #按照数据的顺序，一次只拿一个数据，下次再去就从第二个取了，因为第一个被取出去了，取一次就没有了，结果也都是元祖格式的
  fetchone：(1, '男', 1, '理解')
  fetchone：(2, '女', 1, '钢蛋')
  fetchall：((3, '男', 1, '张三'), (4, '男', 1, '张一')）

#上面fetch的结果都是元祖格式的，没法看出哪个数据是对应的哪个字段，这样是不是不太好看，想一想，我们可以通过python的哪一种数据类型，能把字段和对应的数据表示出来最清晰，当然是字典{'字段名':值}
#我们可以再创建游标的时候，在cursor里面加上一个参数：cursor=conn.cursor(cursor=pymysql.cursors.DictCursor)获取的结果就是字典格式的，fetchall或者fetchmany取出的结果是列表套字典的数据形式

上面我们说，我们的数据取一次是不是就没有了啊，实际上不是的，这个取数据的操作就像读取文件内容一样，每次read之后，光标就移动到了对应的位置，我们可以通过seek来移动光标
同样，我们可以移动游标的位置，继续取我们前面的数据,通过cursor.scroll(数字，模式)，第一个参数就是一个int类型的数字，表示往后移动的记录条数，第二个参数为移动的模式，有两个值：absolute：绝对移动，relative：相对移动
#绝对移动：它是相对于所有数据的起始位置开始往后面移动的
#相对移动：他是相对于游标的当前位置开始往后移动的

#绝对移动的演示
#print(cursor.fetchall())
#cursor.scroll(3,'absolute') #从初始位置往后移动三条，那么下次取出的数据为第四条数据
#print(cursor.fetchone())

#相对移动的演示
#print(cursor.fetchone())
#cursor.scroll(1,'relative') #通过上面取了一次数据，游标的位置在第二条的开头，我现在相对移动了1个记录，那么下次再取，取出的是第三条，我相对于上一条，往下移动了一条
#print(cursor.fetchone())

print(res) #一个数字

cursor.close() #关闭游标
conn.close()   #关闭连接

if res:
    print('登录成功')
else:
    print('登录失败')
```

#### **2.execute()之sql注入**

​	之前我们进行用户名密码认证是先将用户名和密码保存到一个文件中，然后通过读文件里面的内容，来和客户端发送过来的用户名密码进行匹配，现在我们学了数据库，我们可以将这些用户数据保存到数据库中，然后通过数据库里面的数据来对客户端进行用户名和密码的认证。

　　　　自行创建一个用户信息表userinfo，里面包含两个字段，username和password，然后里面写两条记录

　　　　![img](https://img2018.cnblogs.com/blog/988061/201811/988061-20181128152923749-1640903707.png)



```python
#我们来使用数据来进行一下用户名和密码的认证操作
import pymysql

conn = pymysql.connect(
    host='127.0.0.1',
    port=3306,
    user='root',
    password='666',
    database='crm',
    charset='utf8'
)

cursor = conn.cursor(pymysql.cursors.DictCursor)
uname = input('请输入用户名：')
pword = input('请输入密码：')

sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)

res = cursor.execute(sql) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不

print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1
if res:
    print('登陆成功')
else:
    print('用户名和密码错误！')

#通过上面的验证方式，比我们使用文件来保存用户名和密码信息的来进行验证操作要方便很多。

```

　但是我们来看下面的操作，如果将在输入用户名的地方输入一个 chao'空格然后--空格然后加上任意的字符串，就能够登陆成功，也就是只知道用户名的情况下，他就能登陆成功的情况：

```python
uname = input('请输入用户名：')
pword = input('请输入密码：')

sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)
print(sql)
res = cursor.execute(sql) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不

print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1
if res:
    print('登陆成功')
else:
    print('用户名和密码错误！')
#运行看结果：居然登陆成功
请输入用户名：chao' -- xxx
请输入密码：
select * from userinfo where username='chao' -- xxx' and password='';
1
登陆成功

我们来分析一下：
此时uname这个变量等于什么，等于chao' -- xxx,然后我们来看我们的sql语句被这个字符串替换之后是个什么样子：
select * from userinfo where username='chao' -- xxx' and password=''; 其中chao后面的这个'，在进行字符串替换的时候，我们输入的是chao',这个引号和前面的引号组成了一对，然后后面--在sql语句里面是注释的意思，也就是说--后面的sql语句被注释掉了。也就是说，拿到的sql语句是select * from userinfo where username='chao';然后就去自己的数据库里面去执行了，发现能够找到对应的记录，因为有用户名为chao的记录，然后他就登陆成功了，但是其实他连密码都不知道，只知道个用户名。。。，他完美的跳过了你的认证环节。
```

然后我们再来看一个例子，直接连用户名和密码都不知道，但是依然能够登陆成功的情况：

```python
请输入用户名：xxx' or 1=1 -- xxxxxx
请输入密码：
select * from userinfo where username='xxx' or 1=1 -- xxxxxx' and password='';
3
登陆成功

我们只输入了一个xxx' 加or 加 1=1 加 -- 加任意字符串
看上面被执行的sql语句你就发现了，or 后面跟了一个永远为真的条件，那么即便是username对不上，但是or后面的条件是成立的，也能够登陆成功。
```

上面两个例子就是两个sql注入的问题，看完上面这两个例子，有没有感觉后背发凉啊同志们，别急，我们来解决一下这个问题，怎么解决呢？

有些网站直接在你输入内容的时候，是不是就给你限定了，你不能输入一些特殊的符号，因为有些特殊符号可以改变sql的执行逻辑，其实不光是--，还有一些其他的符号也能改变sql语句的执行逻辑，这个方案我们是在客户端给用户输入的地方进行限制，但是别人可不可以模拟你的客户端来发送请求，是可以的，他模拟一个客户端，不按照你的客户端的要求来，就发一些特殊字符，你的客户端是限制不了的。所以单纯的在客户端进行这个特殊字符的过滤是不能解决根本问题的，那怎么办？我们服务端也需要进行验证，可以通过正则来将客户端发送过来的内容进行特殊字符的匹配，如果有这些特殊字符，我们就让它登陆失败。

​	在服务端来解决sql注入的问题：不要自己来进行sql字符串的拼接了，pymysql能帮我们拼接，他能够防止sql注入，所以以后我们再写sql语句的时候按下面的方式写：

```python
sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)

以后再写的时候，sql语句里面的%s左右的引号去掉，并且语句后面的%(uname,pword)这些内容也不要自己写了，按照下面的方式写
sql = "select * from userinfo where username=%s and password=%s;"
难道我们不传值了吗，不是的，我们通过下面的形式，在excute里面写参数：
#cursor.execute(sql,[uname,pword]) ，其实它本质也是帮你进行了字符串的替换，只不过它会将uname和pword里面的特殊字符给过滤掉。

看下面的例子：
uname = input('请输入用户名：') #输入的内容是：chao' -- xxx或者xxx' or 1=1 -- xxxxx
pword = input('请输入密码：')

sql = "select * from userinfo where username=%s and password=%s;"
print(sql)
res = cursor.execute(sql,[uname,pword]) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不

print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1
if res:
    print('登陆成功')
else:
    print('用户名和密码错误！')
#看结果：
请输入用户名：xxx' or 1=1 -- xxxxx
请输入密码：
select * from userinfo where username=%s and password=%s;
0
用户名和密码错误！
```

通过pymysql提供的excute完美的解决了问题。

```python
总结咱们刚才说的两种sql注入的语句
#1、sql注入之：用户存在，绕过密码
chao' -- 任意字符

#2、sql注入之：用户不存在，绕过用户与密码
xxx' or 1=1 -- 任意字符
```

​	解决方法总结：

```python
# 原来是我们对sql进行字符串拼接
# sql="select * from userinfo where name='%s' and password='%s'" %(user,pwd)
# print(sql)
# res=cursor.execute(sql)

#改写为（execute帮我们做字符串拼接，我们无需且一定不能再为%s加引号了）
sql="select * from userinfo where name=%s and password=%s" #！！！注意%s需要去掉引号，因为pymysql会自动为我们加上
res=cursor.execute(sql,[user,pwd]) #pymysql模块自动帮我们解决sql注入的问题，只要我们按照pymysql的规矩来。
复制代码
```

#### **3.增、删、改：conn.commit()**

查操作在上面已经说完了，我们来看一下增删改，也要注意，sql语句不要自己拼接，交给excute来拼接

```python
import pymysql
#链接
conn=pymysql.connect(host='localhost',port='3306',user='root',password='123',database='crm',charset='utf8')
#游标
cursor=conn.cursor()

#执行sql语句
#part1
# sql='insert into userinfo(name,password) values("root","123456");'
# res=cursor.execute(sql) #执行sql语句，返回sql影响成功的行数
# print(res)
# print(cursor.lastrowid) #返回的是你插入的这条记录是到了第几条了

#part2
# sql='insert into userinfo(name,password) values(%s,%s);'
# res=cursor.execute(sql,("root","123456")) #执行sql语句，返回sql影响成功的行数
# print(res)
#还可以进行更改操作：
#res=cursor.excute("update userinfo set username='taibaisb' where id=2")
#print(res) #结果为1
#part3
sql='insert into userinfo(name,password) values(%s,%s);'
res=cursor.executemany(sql,[("root","123456"),("lhf","12356"),("eee","156")]) #执行sql语句，返回sql影响成功的行数，一次插多条记录
print(res)
#上面的几步，虽然都有返回结果，也就是那个受影响的函数res，但是你去数据库里面一看，并没有保存到数据库里面，
conn.commit() #必须执行conn.commit,注意是conn，不是cursor，执行这句提交后才发现表中插入记录成功，没有这句，上面的这几步操作其实都没有成功保存。
cursor.close()
conn.close()
```

#### **4.查：fetchone，fetchmany，fetchall**

```python
import pymysql
#链接
conn=pymysql.connect(host='localhost',user='root',password='123',database='egon')
#游标
cursor=conn.cursor()

#执行sql语句
sql='select * from userinfo;'
rows=cursor.execute(sql) #执行sql语句，返回sql影响成功的行数rows,将结果放入一个集合，等待被查询

# cursor.scroll(3,mode='absolute') # 相对绝对位置移动
# cursor.scroll(3,mode='relative') # 相对当前位置移动
res1=cursor.fetchone()
res2=cursor.fetchone()
res3=cursor.fetchone()
res4=cursor.fetchmany(2)
res5=cursor.fetchall()
print(res1)
print(res2)
print(res3)
print(res4)
print(res5)
print('%s rows in set (0.00 sec)' %rows)



conn.commit() #提交后才发现表中插入记录成功
cursor.close()
conn.close()

'''
(1, 'root', '123456')
(2, 'root', '123456')
(3, 'root', '123456')
((4, 'root', '123456'), (5, 'root', '123456'))
((6, 'root', '123456'), (7, 'lhf', '12356'), (8, 'eee', '156'))
rows in set (0.00 sec)
'''
```

#### **5.获取插入的最后一条数据的自增ID**

```python
import pymysql
conn=pymysql.connect(host='localhost',user='root',password='123',database='egon')
cursor=conn.cursor()

sql='insert into userinfo(name,password) values("xxx","123");'
rows=cursor.execute(sql)
print(cursor.lastrowid) #在插入语句后查看

conn.commit()

cursor.close()
conn.close()
```



## 第六节 索引

#### 本节具体内容如下：   

1. **介绍**

2. **索引原理**

3. **索引的数据结构**

4. **聚集索引与辅助索引**

5. **索引管理**

6. **索引测试**

7. **慢查询优化的基本步骤**

   

#### 1.介绍

​	**为何要有索引?**

　　　　一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

　　**什么是索引？**

　　　　索引在MySQL中也叫做“键”或者"key"（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）
　　　　索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。
　　　　索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

　　　　强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据

```
                      30

        10                          40

   5         15               35          66

1    6    11   19          21   39     55    100
```

​	**你是否对索引存在误解？**

　　　　索引是应用程序设计和开发的一个重要方面。若索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响，要找到一个平衡点，这对应用程序的性能至关重要。一些开发人员总是在事后才想起添加索引----我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程之类，他们甚至可能不知道索引的存在，或认为事后让相关DBA加上即可。DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需的时间，并且可能会遗漏一部分的索引。当然索引也并不是越多越好，我曾经遇到过这样一个问题：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了太多的索引，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。

​	

#### 2.索引原理

​	索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等，下面内容看不懂的同学也没关系，能明白这个目录的道理就行了。 那么你想，书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。你再想，你在没有数据的情况下先建索引或者说目录快，还是已经存在好多的数据了，然后再去建索引，哪个快，肯定是没有数据的时候快，因为如果已经有了很多数据了，你再去根据这些数据建索引，是不是要将数据全部遍历一遍，然后根据数据建立索引。你再想，索引建立好之后再添加数据快，还是没有索引的时候添加数据快，索引是用来干什么的，是用来加速查询的，那对你写入数据会有什么影响，肯定是慢一些了，因为你但凡加入一些新的数据，都需要把索引或者说书的目录重新做一个，所以索引虽然会加快查询，但是会降低写入的效率。　　

　　　　**索引的影响**

　　　　　　1、在表中有大量数据的前提下，创建索引速度会很慢

　　　　　　2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低

　　　　**本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

　　　　数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

​	前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了，还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。下图是计算机硬件延迟的对比图，供大家参考：

　　　　 **![img](https://images2017.cnblogs.com/blog/1036857/201709/1036857-20170912010954844-413816327.png)**

　　　　考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。



#### 3.索引的数据结构

前面讲了索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，现在我们来看看索引怎么做到减少IO，加速查询的。任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，等到后面讲算法的时候再将，现在这个阶段，你大概了解一下就行了，别深究~~）。

　　　　![img](https://images2017.cnblogs.com/blog/1036857/201709/1036857-20170912011123500-158121126.png)

　　如上图，是一颗b+树，最上层是树根，中间的是树枝，最下面是叶子节点，关于b+树的定义可以参见[B+树](http://zh.wikipedia.org/wiki/B%2B%E6%A0%91)，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应四个扇区，可以看到每个磁盘块包含几个数据项（深蓝色所示，一个磁盘块里面包含多少数据，一个深蓝色的块表示一个数据，其实不是数据，后面有解释）和指针（黄色所示，看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

　　###b+树的查找过程
　　　　如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。

　　###b+树性质
　　　　1**.索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

　　　　　　比如：你每个叶子节点只存两个数据的情况下，你如果想多加两个数据，你怎么办

　　　　　　　　![img](https://img2018.cnblogs.com/blog/988061/201812/988061-20181201154920816-458715474.png)

　　　　　　　　所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了亲，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低啊，对不对。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。


　　　　2.**索引的最左匹配特性**：简单来说就是你的数据来了以后，从数据块的左边开始匹配，在匹配右边的，知道这句话就行啦~~~~，我们继续学下面的内容。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。



#### 4.聚集索引与辅助索引

​	聚集索引是什么呢，其实就是我们说的那个主键，之前我们说Innodb存储引擎的表，必须有一个主键，还记得为什么吗，我们说过的...不记得了吧，看下面

　　　　还记得MyISAM存储引擎在创建表的时候会在硬盘上生成哪些文件吗，是不是有三个.frm\.MYD\.MYI结尾的三个文件，frm结尾的是表结构，MYD结尾的是数据文件，MYI结尾的就是索引文件，也就是说索引也是存在硬盘上的，那InnoDB引擎呢，创建一个表，在硬盘上会生成.frm\.idb结尾的两个文件，那索引的呢，难道InnoDB就用不了索引吗？怎么可能？之前咱们有没有建立过索引啊，primary key、unique key是不是都叫做索引啊，但是索引那个文件去哪了呢，索引是不可能在表结构.frm（存什么字段什么类型这些东西）的文件中，那就只剩下.idb结尾的数据文件了，索引就在这里面，InnoDB引擎的表，它的索引和数据都在同一个文件里面，所以我一直强调，使用InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据或者说方式，也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。这种索引，我们就称为聚集索引，也就是在聚集数据组织数据的时候，就用这种索引。InnoDB这么做就是为了加速查询效率，因为你经常会遇到基于主键来查询数据的情况，并且通常我们把id字段作为主键，第一点是因为id占用的数据空间不大，第二点是你经常会用到id来查数据。如果你的表有两个字段，一个id一个name，id为主键，当你查询的时候如果where后面的条件是name=多少多少，那么你就没有用到主键给你带来的加速查询的效果（需要主键之外的辅助索引），如果你用where id=多少多少，就会按照我们刚才上面说的哪种树形结构来给你找寻数据了（当然不仅仅有这种树形结构的数据结构类型），能够快速的帮你定位到数据块。这种聚集索引的特点是它会以id字段作为依据，去建立树形结构，但是叶子节点存的是你表中的一条完整记录，一条完整的数据。记住这一点昂，一会将辅助索引的时候，和这个内容有关系，会讲到一个回表的概念。

　　在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2~4次的IO意味着查询时间只需要0.02~0.04秒。

　　数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），

　　聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。

　　聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息

**1.聚集索引**

```
#InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。
    
#如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。
    
#如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。

#由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。
```

​	**聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录**　

示例

```mysql
#参照第六小结测试索引的准备阶段来创建出表s1
mysql> desc s1; #最开始没有主键
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   |     | NULL    |       |
| name   | varchar(20) | YES  |     | NULL    |       |
| gender | char(6)     | YES  |     | NULL    |       |
| email  | varchar(50) | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql> explain select * from s1 order by id desc limit 10; #Using filesort，需要二次排序
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2633472 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+
1 row in set, 1 warning (0.11 sec)

mysql> alter table s1 add primary key(id); #添加主键
Query OK, 0 rows affected (13.37 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from s1 order by id desc limit 10; #基于主键的聚集索引在创建完毕后就已经完成了排序，无需二次排序
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | index | NULL          | PRIMARY | 4       | NULL |   10 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.04 sec)
```

**聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可**

示例

```mysql
mysql> alter table s1 drop primary key;
Query OK, 2699998 rows affected (24.23 sec)
Records: 2699998  Duplicates: 0  Warnings: 0

mysql> desc s1;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   |     | NULL    |       |
| name   | varchar(20) | YES  |     | NULL    |       |
| gender | char(6)     | YES  |     | NULL    |       |
| email  | varchar(50) | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.12 sec)

mysql> explain select * from s1 where id > 1 and id < 1000000; #没有聚集索引，预估需要检索的rows数如下，explain就是预估一下你的sql的执行效率
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2690100 |    11.11 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> alter table s1 add primary key(id);
Query OK, 0 rows affected (16.25 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from s1 where id > 1 and id < 1000000; #有聚集索引，预估需要检索的rows数如下
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1343355 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
1 row in set, 1 warning (0.09 sec)
```



**2.辅助索引**

​	就是我们在查询的时候，where后面需要写id之外的其他字段名称来进行查询，比如说是where name=xx，没法用到主键索引的效率，怎么办，就需要我们添加辅助索引了，给name添加一个辅助索引。

​	表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

​	叶子节点存放的是对应的那条数据的主键字段的值，除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark），其实这个书签你可以理解为是一个{'name字段'，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。如果我们select 后面要的是name，我们直接就可以在辅助索引的叶子节点找到对应的name值，比如：select name from tb1 where name='xx'；这个xx值你直接就在辅助索引的叶子节点就能找到，这种我们也可以称为覆盖索引。如果你select后面的字段不是name，例如：select age from tb1 where name='xx'；也就是说，我通过辅助索引的叶子节点不能直接拿到age的值，需要通过辅助索引的叶子节点中保存的主键id的值再去通过聚集索引来找到完整的一条记录，然后从这个记录里面拿出age的值，这种操作有时候也成为回表操作，就是从头再回去查一遍，这种的查询效率也很高，但是比覆盖索引低一些，再说一下昂，再辅助索引的叶子节点就能找到你想找的数据可称为覆盖索引。再看看下面的解释：

​	由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键或者称为主键的值。如下图

　　　　　　![img](https://images2018.cnblogs.com/blog/1036857/201711/1036857-20171126001518515-1178335624.png)

　　　　辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录，这种查找的效率也是非常高。

　　　　举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。

　　　　![img](https://images2018.cnblogs.com/blog/1036857/201711/1036857-20171126002330609-628176603.png)

　　概念基本就说完了，下面我们来点实际操作吧。



#### 5.索引管理

语法

```mysql
#方法一：创建表时
    　　CREATE TABLE 表名 (
                字段名1  数据类型 [完整性约束条件…],
                字段名2  数据类型 [完整性约束条件…],
                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                );


#方法二：CREATE在已存在的表上创建索引
        CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                     ON 表名 (字段名[(长度)]  [ASC |DESC]) ;


#方法三：ALTER TABLE在已存在的表上创建索引
        ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                             索引名 (字段名[(长度)]  [ASC |DESC]) ;
                             
#删除索引：DROP INDEX 索引名 ON 表名字;
```

​	常用操作：

```mysql
添加主键索引:
	创建的时候添加:  添加索引的时候要注意,给字段里面数据大小比较小的字段添加,给字段里面的数据区分度高的字段添加.
	聚集索引的添加方式
创建的是添加
Create table t1(
Id int primary key,
)
Create table t1(
Id int,
Primary key(id)
)

表创建完了之后添加
Alter table 表名 add primary key(id)
删除主键索引:
Alter table 表名 drop primary key;


唯一索引:
Create table t1(
Id int unique,
)

Create table t1(
Id int,
Unique key uni_name (id)
)

表创建好之后添加唯一索引:
alter table s1 add unique key  u_name(id);
删除:
Alter table s1 drop index u_name;

普通索引:
创建:
Create table t1(
Id int,
Index index_name(id)
)
Alter table s1 add index index_name(id);
Create index index_name on s1(id);

删除:
Alter table s1 drop index u_name;
DROP INDEX 索引名 ON 表名字;
```

简单示例

```mysql
#方式一
create table t1(
    id int,
    name char,
    age int,
    sex enum('male','female'),
    unique key uni_id(id),
    index ix_name(name) #index没有key
);


#方式二
create index ix_age on t1(age);

#方式三
alter table t1 add index ix_sex(sex);

#查看
mysql> show create table t1;
| t1    | CREATE TABLE `t1` (
  `id` int(11) DEFAULT NULL,
  `name` char(1) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `sex` enum('male','female') DEFAULT NULL,
  UNIQUE KEY `uni_id` (`id`),
  KEY `ix_name` (`name`),
  KEY `ix_age` (`age`),
  KEY `ix_sex` (`sex`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
```



#### 6.索引测试

```mysql
#1. 准备表
create table s1(
id int,
name varchar(20),
gender char(6),
email varchar(50)
);

#2. 创建存储过程，实现批量插入记录
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert1()
BEGIN
    declare i int default 1;
    while(i<3000000)do
        insert into s1 values(i,'egon','male',concat('egon',i,'@oldboy'));
        set i=i+1;
    end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号

#3. 查看存储过程
show create procedure auto_insert1\G 

#4. 调用存储过程
call auto_insert1();
```

**在没有索引的前提下测试查询速度**

```mysql
#无索引：mysql根本就不知道到底是否存在id等于333333333的记录，也不知道存在几条id=333333333的记录，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢
mysql> select * from s1 where id=333333333;
Empty set (0.33 sec)
```

**在表中已经存在大量数据的前提下，为某个字段段建立索引，建立速度会很慢**

　![img](https://images2017.cnblogs.com/blog/1036857/201709/1036857-20170913163337125-480382090.png)

　或者用alter table s1 add primary key(id);加主键，建索引很慢的。

 **在索引建立完毕后，以该字段为查询条件时，查询速度提升明显**

![img](https://images2017.cnblogs.com/blog/1036857/201709/1036857-20170913171928047-457783306.png)

　　　　PS：

　　　　1. mysql先去索引表里根据b+树的搜索原理很快搜索到id等于333333333的记录不存在，IO大大降低，因而速度明显提升

　　　　2. 我们可以去mysql的data目录下找到该表，可以看到占用的硬盘空间多了

　　　　3. 需要注意，如下图**

　　　　**![img](https://images2017.cnblogs.com/blog/1036857/201709/1036857-20170913163702469-1581818233.png)**

​	总结

```
#1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引

#2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。
建完以后，再查询就会很快了。

#3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI

MySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。
因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.
```

​	　你想一下，是不是全部加索引就一定好的呢，首先，我们加上索引，查询时快了，但是写入的时候就慢了，还记得吗，每次插入新的记录，你的整个索引结构都会跟着改，所以如果你乱加索引，你会发现，即便是你的网站没有几个人在注册，或者说没有几个写入数据的操作，你的磁盘IO会居高不下，磁盘在疯狂的转，因为你每插入一条数据，我们的索引都需要重新建，重建的索引要写入硬盘里面的，还记得我们给那三百万条数据建索引的时候的速度吗？每次都要把所有的数据取出来，做好一个数据结构，然后再写回硬盘，也就是要经历很多的IO才能实现这个事儿，所以乱加索引的一个弊端就是，你很少的写入都会导致你的磁盘IO非常的高，导致效率很差，所以我们要学一下怎么正确的加索引。



#### 7.**慢查询优化的基本步骤**

```
0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3.order by limit 形式的sql语句让排序的表优先查
4.了解业务方使用场景
5.加索引时参照建索引的几大原则
6.观察结果，不符合预期继续从0分析
```



## 第七节 创建用户和授权

#### 本节具体内容如下：   

1. **对新用户增删改**

2. **对当前的用户授权管理**

   

​	我们知道我们的最高权限管理者是root用户，它拥有着最高的权限操作。包括select、update、delete、update、grant等操作。那么一般情况在公司之后DBA工程师会创建一个用户和密码，让你去连接数据库的操作，并给当前的用户设置某个操作的权限（或者所有权限）。那么这时就需要我们来简单了解一下：

- 如何创建用户和密码
- 给当前的用户授权
- 移除当前用户的权限

　　如果你想创建一个新的用户，则需要以下操作：

​	**进入到mysql数据库下**

```mysql
mysql> use mysql
Database changed
```

#### **1.对新用户增删改**

```mysql
1.创建用户:
# 指定ip：192.118.1.1的chao用户登录
create user 'chao'@'192.118.1.1' identified by '123';
# 指定ip：192.118.1.开头的chao用户登录
create user 'chao'@'192.118.1.%' identified by '123';
# 指定任何ip的chao用户登录
create user 'chao'@'%' identified by '123';

2.删除用户
drop user '用户名'@'IP地址';


3.修改用户
rename user '用户名'@'IP地址' to '新用户名'@'IP地址';

4.修改密码
set password for '用户名'@'IP地址'=Password('新密码');
```

#### **2.对当前的用户授权管理**

```mysql
#查看权限
show grants for '用户'@'IP地址'

#授权 chao用户仅对db1.t1文件有查询、插入和更新的操作
grant select ,insert,update on db1.t1 to "chao"@'%';

# 表示有所有的权限，除了grant这个命令，这个命令是root才有的。chao用户对db1下的t1文件有任意操作
grant all privileges  on db1.t1 to "chao"@'%';
#chao用户对db1数据库中的文件执行任何操作
grant all privileges  on db1.* to "chao"@'%';
#chao用户对所有数据库中文件有任何操作
grant all privileges  on *.*  to "chao"@'%';
 
#取消权限
 
# 取消chao用户对db1的t1文件的任意操作
revoke all on db1.t1 from 'chao'@"%";  

# 取消来自远程服务器的chao用户对数据库db1的所有表的所有权限

revoke all on db1.* from 'chao'@"%";  

取消来自远程服务器的chao用户所有数据库的所有的表的权限
revoke all privileges on *.* from 'chao'@'%';
```



## 第八节 MySQL数据备份与还原

#### 本节具体内容如下：   

1. **数据备份**
2. **数据恢复**



​	经常有朋友问我，DBA到底是做什么的，百科上说：数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。 

　　百科出来的内容总是那么的专业，让人看完之后的感觉是很解释的很好，但是我没有看懂或者似懂非懂的模糊感。。哈哈，其实我认为，DBA主要做三件事情：1.保证公司的数据不丢失不损坏 2.提高数据库管理系统的工作性能

　　对于现在的公司来讲，数据变得尤为重要，可以说最重要，你的网站可以无法访问，服务器可以宕机，但是数据绝对不能丢，所以我们本节内容就冲着如果保护好数据而来的。本篇博客的内容并不是很深入，毕竟不是专业的DBA，只是作为超哥的讲课内容，让大家学一些数据备份的基本操作，入门级别咱们只讲一下mysqldump指令，至于如果做主从复制，双机热备，数据库高可用，数据库集群，大家可以去看我其他的博客，博客写完了，目前还在整理，整理好之后我就发出来供大家批评指正，共同学习~~~，因为毕竟咱们学的是开发，本篇内容就当作是拓展自己的知识领域吧，对你来讲都是很有好处的，大家加油吧

　　那么我们就来学一下mysqldump指令。

#### 1.数据备份

```mysql
1.首先我们先创建一个名为crm2的库

　　　　mysql> create database crm2;
　　　　mysql> show create database crm2;
　　2.切换到crm2库下
　　　　mysql> use crm2;
　　3.创建两张表，student表和class表
　　　　mysql> create table tb1(id int primary key,name char(8) not null,age int,class_id int not null);
　　　　Query OK, 0 rows affected (0.63 sec)

　　　　mysql> create table class(id int primary key,cname char(20) not null);
　　　　Query OK, 0 rows affected (0.34 sec)

　　4.给两张表插入一些数据

　　　　mysql> insert into class values(1,'一班'),(2,'二班');
　　　　mysql> insert into student values(1,'Jaden',18,1),(2,'太白',45,1),(3,'彦涛',30,2);

　　5.查看一下两个表的数据
　　　　mysql> select * from student;
　　　　+----+--------+------+----------+
　　　　| id | name | age | class_id |
　　　　+----+--------+------+----------+
　　　　| 1 | Jaden | 18 | 1 |
　　　　| 2 | 太白 | 45 | 1 |
　　　　| 3 | 彦涛 | 30 | 2 |
　　　　+----+--------+------+----------+
　　　　3 rows in set (0.00 sec)

　　　　mysql> select * from class;
　　　　+----+--------+
　　　　| id | cname |
　　　　+----+--------+
　　　　| 1 | 一班 |
　　　　| 2 | 二班 |
　　　　+----+--------+
　　　　2 rows in set (0.00 sec)
```

  	好，前期工作准备完毕，下面我们来通过mysqldump指令进行备份，在cmd窗口下执行下面的指令，注意不是进入mysql里面输入的，是在外面面。

​	C:\WINDOWS\system32>mysqldump -h 127.0.0.1 -u root -p666 crm2 > f:\数据库备份练习\crm2.sql
​	Warning: Using a password on the command line interface can be insecure. (这个提示是因为我把密码显示出来了，自己在自己电脑上测试的时候，这个警告可以忽略)

​	然后我们就会发现在这个'f:\数据库备份练习\'路径下面就有了crm2.sql文件
​	然后我们通过nodepad++(随便一个文本编辑器都可以)，打开看看里面的内容：  

```mysql
-- MySQL dump 10.13 Distrib 5.6.42, for Win64 (x86_64)
　　　　--
　　　　-- Host: 127.0.0.1 Database: crm2
　　　　-- ------------------------------------------------------
　　　　-- Server version	5.6.42

　　　　/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
　　　　/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
　　　　/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
　　　　/*!40101 SET NAMES utf8 */;
　　　　/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
　　　　/*!40103 SET TIME_ZONE='+00:00' */;
　　　　/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
　　　　/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
　　　　/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
　　　　/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

　　　　--
　　　　-- Table structure for table `class`
　　　　--

　　　　DROP TABLE IF EXISTS `class`; --如果之前存在class表，就将之前的class表删除
　　　　/*!40101 SET @saved_cs_client = @@character_set_client */;
　　　　/*!40101 SET character_set_client = utf8 */;
　　　　CREATE TABLE `class` ( --创建表
　　　　`id` int(11) NOT NULL,
　　　　`cname` char(20) NOT NULL,
　　　　PRIMARY KEY (`id`)
　　　　) ENGINE=InnoDB DEFAULT CHARSET=utf8;
　　　　/*!40101 SET character_set_client = @saved_cs_client */;

　　　　--
　　　　-- Dumping data for table `class`
　　　　--

　　　　LOCK TABLES `class` WRITE; --锁表
　　　　/*!40000 ALTER TABLE `class` DISABLE KEYS */;
　　　　INSERT INTO `class` VALUES (1,'一班'),(2,'二班'); --插入数据
　　　　/*!40000 ALTER TABLE `class` ENABLE KEYS */;
　　　　UNLOCK TABLES; --解锁
　　　　......
```



​	  等等大致内容(如果你插入的数据有中文，这里显示的确实乱码的同学，往回看看我的关于修改mysql字符集编码的博客，将编码改为统一的，然后重新操作一遍就可以了)

​	上面的这个指令的意思就是将crm2这个库，备份到这个'f:\数据库备份练习\'路径下，并且命名为crm2.sql文件。

　　执行备份语句的时候，其中可以加上很多的参数，用来添加一些备份的时候的特殊要求的，其中有一个-B参数，执行备份语句时，如果加上了-B参数，那么将来再执行数据还原的时候，就不需要自己到数据库里面去先创建一个crm2这个库了，并且执行数据还原语句的时候就不需要指定crm2这个库了，如果没有加-B参数，就需要自行到数据库中先创建一个crm2这个库，并且执行语句是要指定将数据恢复到这个crm2库里面，看对比：
　　首先上面我们执行的语句中没有加上-B参数，那么恢复数据的时候，怎么恢复呢，看下面的语句  

```mysql
	   1.连接到数据库中，并创建crm2这个库
　　　　　　mysql -u root -p666
　　　　　　mysql> create database crm2;
　　　　2.退出mysql或者重新启动一个cmd窗口，然后执行
　　　　　　mysql -uroot -p 库名 < mysqldump出来的那个sql文件的路径
　　　　例如：mysql -uroot -p crm2< f:\数据库备份练习\crm2.sql
　　　　3.这样就恢复好了，我们连接上数据库并查看里面的内容：
　　　　　　mysql -u root -p666
　　　　　　use crm2;
　　　　　　mysql> show tables;
　　　　　　+----------------+
　　　　　　| Tables_in_crm2 |
　　　　　　+----------------+
　　　　　　| class |
　　　　　　| student |
　　　　　　+----------------+
　　　　　　2 rows in set (0.00 sec)

　　　　　　mysql> select * from student;
　　　　　　+----+--------+------+----------+
　　　　　　| id | name | age | class_id |
　　　　　　+----+--------+------+----------+
　　　　　　| 1 | Jaden | 18 | 1 |
　　　　　　| 2 | 太白 | 45 | 1 |
　　　　　　| 3 | 彦涛 | 30 | 2 |
　　　　　　+----+--------+------+----------+
　　　　　　3 rows in set (0.00 sec)

　　　　　　mysql> desc student;
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　| Field | Type | Null | Key | Default | Extra |
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　| id | int(11) | NO | PRI | NULL | |
　　　　　　| name | char(8) | NO | | NULL | |
　　　　　　| age | int(11) | YES | | NULL | |
　　　　　　| class_id | int(11) | NO | | NULL | |
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　4 rows in set (0.02 sec)
```

​	就这么简单我们就将数据库恢复了，表中的数据和表结构都恢复了。


​	执行mysqldump的时候加上了-B参数，那么恢复数据的时候，就不需要指定是恢复那个库里面的数据了，也不需要提前到数据库中创建一个crm2库了，因为-B参数导出的文件中自带创建数据库和连接数据库的功能：(使用-B参数备份出来的内容自带create database 库名和use 库名的功能)  

```mysql
	   1.mysqldump -uroot -p -B crm2> f:\数据库备份练习\crm2.sql

　　　　2.在cmd窗口下执行：mysql -uroot -p < f:\数据库备份练习\crm2.sql
　　　　3.查看一下是否恢复了：
　　　　　　mysql> show databases;
　　　　　　+--------------------+
　　　　　　| Database |
　　　　　　+--------------------+
　　　　　　| information_schema |
　　　　　　| crm2 |
　　　　　　| d1 |
　　　　　　| mysql |
　　　　　　| performance_schema |
　　　　　　| test |
　　　　　　+--------------------+
　　　　　　mysql> use crm2;
　　　　　　Database changed
　　　　　　mysql> show tables;
　　　　　　+----------------+
　　　　　　| Tables_in_crm2 |
　　　　　　+----------------+
　　　　　　| class |
　　　　　　| student |
　　　　　　+----------------+
　　　　　　2 rows in set (0.00 sec)
　　　　　　mysql> select * from class;
　　　　　　+----+--------+
　　　　　　| id | cname |
　　　　　　+----+--------+
　　　　　　| 1 | 一班 |
　　　　　　| 2 | 二班 |
　　　　　　+----+--------+
　　　　　　2 rows in set (0.00 sec)

　　　　　　mysql> desc student;
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　| Field | Type | Null | Key | Default | Extra |
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　| id | int(11) | NO | PRI | NULL | |
　　　　　　| name | char(8) | NO | | NULL | |
　　　　　　| age | int(11) | YES | | NULL | |
　　　　　　| class_id | int(11) | NO | | NULL | |
　　　　　　+----------+---------+------+-----+---------+-------+
　　　　　　4 rows in set (0.02 sec)
```

​	上面我们就完成了一个简单数据库备份和恢复的过程(在linux下面还可以在导出的时候压缩文件内容，减小空间占用mysqldump -uroot -p -B crm2|gzip> f:\数据库备份练习\crm2.sql.gz，windows好像是没有自带的zip压缩指令，大家有兴趣的可以去查一下，作为了解吧)

​	原理：其实很简单，就是把数据从mysql库里面以逻辑的sql语句的形式直接输出或者生成备份文件的过程。

​	上面我们说完了单库备份，下面来看看多个库怎么备份呀  

```shell
C:\WINDOWS\system32>mysqldump -uroot -p -B crm2 mysql> f:\数据库备份练习\crm2mysql.sql
Enter password: ***
```

​	就是多个库名用空格分开，这样备份出来的sql文件还是一个，也就是这两个库都备份到一个文件里面了。一般作备份的时候的文件名字都是库名.sql，多个库一般就是库名_库名_库名.sql。


​	那如果我们将很多的库都是一起备份的，但是我们只想恢复其中一个库怎么办，这样搞是不是就不太合适了(因为一个文件算是一个备份，在进行恢复的时候，一下就将文件里面的所有的库都还原了，效率低不说，还麻烦)，那就需要分库备份了，也就是将每个库分开来进行备份，自己备份自己的，一个一个来。

​	其实就是执行多个单库备份的语句  

```shell
mysqldump -uroot -p -B crm2> f:\数据库备份练习\crm2.sql
mysqldump -uroot -p -B mysql> f:\数据库备份练习\crm2.sql
...
```

​	但是如果库比较多(企业的数据库里一般都会有多个库)，这么写就比较麻烦了，所以需要获取所有数据库的库名，然后根据库名来循环执行上面的单库备份的语句，并将库名作为变量放到语句里面进行循环。需要写脚本(就是一堆系统指令组成的程序)来做这件事情了，具体怎么做，咱们就不说啦，目前知道一下就可以了(写一个.sh文件，然后sh+文件来执行这个文件，文件里面写个for循环就行了，等你学会写shell脚本就会了)。

```
备份表：
　　　　　　上面我们说的是如何备份库，现在我们来看看如果备份其中的某个表：
　　　　　　语法：mysqldump -u 用户名 -p 库名 表名> (路径)备份的文件名
　　　　　　　　mysqldump -uroot -p crm2 student> f:\数据库备份练习\crm2_table_student.sql

　　　　单纯进行表备份的时候，就不用写-B参数了，因为库crm2后面就是student表了，也就是说你的crm2库还在呢

　　　　备份多个表：
　　　　　　语法：mysqldump -u 用户名 -p 库名 表名1 表名2> (路径)备份的文件名

　　　　和多个库一起备份有一个同样的问题，就是如果我只需要恢复某一张表怎么办，上面的多表备份是不是也不太合适啊，所以又要进行分表备份
　　　　又是同样的套路，获取所有的表名，写一个循环脚本，执行单表备份的指令。
　　　　分库分表备份有些缺点：文件多，很碎，数据量非常大的时候，效率低
　　　　　　1.做一个完整的全备，再做一个分库分表的备份
　　　　　　2.脚本批量恢复多个sql文件。
　　　　

　　备份数据库表结构：
　　　　利用mysqldump -d参数只备份表的结果，例如：备份crm2库的所有表的结构：

　　　　C:\WINDOWS\system32>mysqldump -uroot -p -B -d crm2> f:\数据库备份练习\crm2stru.sql
　　　　Enter password: ***
```

​	备份出来的文件打开一看，就没有了插入数据的部分。

​	mysqldump的关键参数说明：

```
		  1.-B指定多个库，增加建库语句和use 语句
　　　　　　2.--compact 去掉注释，适合调试输出，生产上不用
　　　　　　3.-A或者--all-databases
　　　　　　　　例如：C:\WINDOWS\system32>mysqldump -uroot -p -B -A> f:\数据库备份练习\all.sql
　　　　　　　　Enter password: ***

　　　　　　4.-F刷新binlog日志(binlog具体是什么，后面咱们再解释)
　　　　　　5.--master-data 增加binlog日志文件名及对应的为支点。
　　　　　　6.-x，--lock-all-tables 将所有的表锁住，一般mysql引擎都是锁表，全部都不能使用了，所有不太友好

　　　　　　7.--add-locks这个选项会在INSERT语句中捆上一个LOCK TABLE和UNLOCK TABLE语句。这就防止在这些记录被再次导入数据库时其他用户对表进行的操作(mysql默认是加上的)
　　　　　　8.-l，--lock-tables Lock all tables for read
　　　　　　9.-d 只备份表结构
　　　　　　10.-t 只备份数据
　　　　　　11. --single-transaction 开启事务，适合innodb事务数据库备份
　　　　　　　　InnoDB表在备份时，通常启用选项--single-transaction来保证备份的一致性，实际上他的工作原理时设定本次会话的隔离界别为：REPEATABLE READ，以确保本次会话(dump)时，不会看到其他会话已经提交了数据。

　　　　　　　　MyISAM全库备份指令推荐：(gzip是压缩文件为zip类型的)
　　　　　　　　mysqldump -uroot -p666 -A -B --master-data=2 -x|gzip>f:\数据库备份练习\all.sql.gz
　　　　　　　　InnoDB全库备份指令推荐：
　　　　　　　　mysqldump -uroot -p666 -A -B --master-data=2 --single-transaction|gzip>f:\数据库备份练习\all.sql.gz
```

#### 	**2.数据恢复**

```
一、通过source命令恢复数据库
　　　　进入mysql数据库控制台，mysql -uroot -p666登陆后
　　　　mysql>use 数据库;
　　　　然后使用source命令，后面参数为脚本文件(如这里用到的是.sql文件，如果你备份的是.txt文件，那这里写.txt文件)

　　　　mysql>source crm2.sql #这个文件是系统路径下的，默认是登陆mysql前的系统路径，在mysql中查看系统路径的方法是通过system+系统命令来搞的
　　　　mysql>system ls
二、利用mysql命名恢复(标准)
　　　　mysql -root -p666 -e "use crm2;drop table student;show tables;" 必须是双引号
　　　　mysql -uroot -p666 crm2<f:\数据库备份练习\crm2.sql
　　　　mysql -uroot -p666 -e "use crm2;show tables;"

　　　　注：如果sql文件里面没有use db这样的字样时，在导入时就要指定数据库名了。

　　　　mysql -uroot -p666 crm2<.sql文件

　　　　建议备份数据库时都指定上-B参数，效果好

　　　　说明：mysql不光可以恢复mysqldump的备份，只要文件中是sql语句，都可以通过mysql命令执行到数据库中

　　　　mysql 带-e参数实现非交互式对话，就是不需要到mysql里面去，在外面执行里面的指令的方法,例如：mysql -uroot -p666 -e "use crm2;show tables;"，但是语句必须是双引号包裹。


　　　　批量恢复库：找到所有的数据库名，然后通过库名去循环恢复
```

